From 697880d188aac8fd0a5401846766d793e56a7afc Mon Sep 17 00:00:00 2001
From: Steffen Sledz <sledz@dresearch-fe.de>
Date: Fri, 29 Jan 2016 20:06:38 +0100
Subject: [PATCH] race condition fix, HYP-12917

Signed-off-by: Sascha Dierberg <dierberg@dresearch-fe.de>
---
 src/common/phys_mem_allocator.c | 35 ++++++++++++++++++++++-------------
 src/common/phys_mem_allocator.h |  2 +-
 src/ipu/allocator.c             |  7 +++++++
 src/v4l2src/v4l2_buffer_pool.c  |  2 +-
 4 files changed, 31 insertions(+), 15 deletions(-)

diff --git a/src/common/phys_mem_allocator.c b/src/common/phys_mem_allocator.c
index 5d1a585..532b21d 100644
--- a/src/common/phys_mem_allocator.c
+++ b/src/common/phys_mem_allocator.c
@@ -89,7 +89,7 @@ static GstImxPhysMemory* gst_imx_phys_mem_new_internal(GstImxPhysMemAllocator *p
 
 	phys_mem->mapped_virt_addr = NULL;
 	phys_mem->phys_addr = 0;
-	phys_mem->mapping_refcount = 0;
+	g_atomic_int_set(&phys_mem->mapping_refcount, 0);
 	phys_mem->internal = NULL;
 
 	gst_memory_init(GST_MEMORY_CAST(phys_mem), flags, GST_ALLOCATOR_CAST(phys_mem_alloc), parent, maxsize, align, offset, size);
@@ -163,6 +163,11 @@ static void gst_imx_phys_mem_allocator_free(GstAllocator *allocator, GstMemory *
 	GstImxPhysMemAllocator *phys_mem_alloc = GST_IMX_PHYS_MEM_ALLOCATOR(allocator);
 	GstImxPhysMemAllocatorClass *klass = GST_IMX_PHYS_MEM_ALLOCATOR_CLASS(G_OBJECT_GET_CLASS(allocator));

+	while (g_atomic_int_dec_and_test(&phys_mem->mapping_refcount))
+	{
+		GST_LOG_OBJECT(phys_mem_alloc, "unmapping memory block %p (phys addr %" GST_IMX_PHYS_ADDR_FORMAT "), current mapping refcount = %ld -> %ld",(gpointer)phys_mem, phys_mem->phys_addr, phys_mem->mapping_refcount, (phys_mem->mapping_refcount > 0) ? (phys_mem->mapping_refcount - 1) : 0);
+		klass->unmap_phys_mem(phys_mem_alloc, phys_mem);
+	} 
 	klass->free_phys_mem(phys_mem_alloc, phys_mem);
 
 	GST_INFO_OBJECT(allocator, "freed block %p at phys addr %" GST_IMX_PHYS_ADDR_FORMAT " with size: %u", (gpointer)memory, phys_mem->phys_addr, memory->size);
@@ -179,13 +183,11 @@ static gpointer gst_imx_phys_mem_allocator_map(GstMemory *mem, gsize maxsize, Gs
 
 	GST_LOG_OBJECT(phys_mem_alloc, "mapping %u bytes from memory block %p (phys addr %" GST_IMX_PHYS_ADDR_FORMAT "), current mapping refcount = %ld -> %ld", maxsize, (gpointer)mem, phys_mem->phys_addr, phys_mem->mapping_refcount, phys_mem->mapping_refcount + 1);
 
-	phys_mem->mapping_refcount++;
-
 	/* In GStreamer, it is not possible to map the same buffer several times
 	 * with different flags. Therefore, it is safe to use refcounting here,
 	 * since the value of "flags" will be the same with multiple map calls. */
 
-	if (phys_mem->mapping_refcount == 1)
+	if (0 == g_atomic_int_add(&phys_mem->mapping_refcount, 1))// || phys_mem->mapped_virt_addr == NULL)
 	{
 		phys_mem->mapping_flags = flags;
 		return klass->map_phys_mem(phys_mem_alloc, phys_mem, maxsize, flags);
@@ -206,18 +208,18 @@ static void gst_imx_phys_mem_allocator_unmap(GstMemory *mem)
 
 	GST_LOG_OBJECT(phys_mem_alloc, "unmapping memory block %p (phys addr %" GST_IMX_PHYS_ADDR_FORMAT "), current mapping refcount = %ld -> %ld", (gpointer)mem, phys_mem->phys_addr, phys_mem->mapping_refcount, (phys_mem->mapping_refcount > 0) ? (phys_mem->mapping_refcount - 1) : 0);
 
-	if (phys_mem->mapping_refcount > 0)
+	if (g_atomic_int_dec_and_test(&phys_mem->mapping_refcount))
 	{
-		phys_mem->mapping_refcount--;
-		if (phys_mem->mapping_refcount == 0)
-			klass->unmap_phys_mem(phys_mem_alloc, phys_mem);
+		klass->unmap_phys_mem(phys_mem_alloc, phys_mem);
 	}
+	g_assert(g_atomic_int_get(&phys_mem->mapping_refcount) >= 0);
 }
 
 
 static GstMemory* gst_imx_phys_mem_allocator_copy(GstMemory *mem, gssize offset, gssize size)
 {
 	GstImxPhysMemory *copy;
+	GstImxPhysMemory *phys_mem = (GstImxPhysMemory *)mem;
 	GstImxPhysMemAllocator *phys_mem_alloc = (GstImxPhysMemAllocator*)(mem->allocator);
 
 	if (size == -1)
diff --git a/src/common/phys_mem_allocator.h b/src/common/phys_mem_allocator.h
index 8097e56..4eddc68 100644
--- a/src/common/phys_mem_allocator.h
+++ b/src/common/phys_mem_allocator.h
@@ -69,7 +69,7 @@ struct _GstImxPhysMemory
 
 	/* Counter to ensure the memory block isn't (un)mapped
 	 * more often than necessary */
-	long mapping_refcount;
+	volatile gint mapping_refcount;
 
 	/* pointer for any additional internal data an allocator may define
 	 * not for outside use; allocators do not have to use it */
diff --git a/src/ipu/allocator.c b/src/ipu/allocator.c
index 075ab7b..5fce37d 100644
--- a/src/ipu/allocator.c
+++ b/src/ipu/allocator.c
@@ -101,6 +101,12 @@ static gpointer gst_imx_ipu_map_phys_mem(GstImxPhysMemAllocator *allocator, GstI
	int prot = 0;
	GstImxIpuAllocator *ipu_allocator = GST_IMX_IPU_ALLOCATOR(allocator);

+	g_assert(1 == g_atomic_int_get(&phys_mem->mapping_refcount));
+
+	if (phys_mem->mapped_virt_addr != NULL)
+	{
+		GST_WARNING_OBJECT(ipu_allocator, "memory-mapping: phys_mem->mapped_virt_addr != NULL %p refcount %i", phys_mem->mapped_virt_addr, phys_mem->mapping_refcount);
+	}
	/* As explained in gst_imx_phys_mem_allocator_map(), the flags are guaranteed to
	 * be the same when a memory block is mapped multiple times, so the value of
	 * "flags" will be identical if map() is called two times, for example. */
@@ -115,9 +119,12 @@ static gpointer gst_imx_ipu_map_phys_mem(GstImxPhysMemAllocator *allocator, GstI
 	{
 		phys_mem->mapped_virt_addr = NULL;
 		GST_ERROR_OBJECT(ipu_allocator, "memory-mapping the IPU framebuffer failed: %s", strerror(errno));
+		g_assert(phys_mem->mapped_virt_addr != NULL);
 		return NULL;
 	}
 
+	g_assert(phys_mem->mapped_virt_addr != NULL);
+
 	GST_LOG_OBJECT(ipu_allocator, "mapped IPU physmem memory:  virt addr %p  phys addr %" GST_IMX_PHYS_ADDR_FORMAT, phys_mem->mapped_virt_addr, phys_mem->phys_addr);
 
 	return phys_mem->mapped_virt_addr;
@@ -128,6 +135,9 @@ static gpointer gst_imx_ipu_map_phys_mem(GstImxPhysMemAllocator *allocator, GstI

 static void gst_imx_ipu_unmap_phys_mem(GstImxPhysMemAllocator *allocator, GstImxPhysMemory *memory)
 {
+	g_assert(0 == g_atomic_int_get(&memory->mapping_refcount));
+	g_assert(memory->mapped_virt_addr != NULL);
+
	if (memory->mapped_virt_addr != NULL)
	{
		if (munmap(memory->mapped_virt_addr, memory->mem.maxsize) == -1)
diff --git a/src/v4l2src/v4l2_buffer_pool.c b/src/v4l2src/v4l2_buffer_pool.c
index ebeafea..1424ee8 100644
--- a/src/v4l2src/v4l2_buffer_pool.c
+++ b/src/v4l2src/v4l2_buffer_pool.c
@@ -178,7 +178,7 @@ static GstFlowReturn gst_imx_v4l2_buffer_pool_alloc_buffer(GstBufferPool *bpool,
 	phys_mem_meta = GST_IMX_PHYS_MEM_META_ADD(buf);
 	// SDG: Hack for tw6869
 	phys_mem_meta->phys_addr =  (*(__u32 *)meta->mem); // meta->vbuffer.m.offset;
-	
+
 	/* Safeguard to catch data loss if in any future i.MX version the types do not match */
 	//g_assert(meta->vbuffer.m.offset == (__u32)(phys_mem_meta->phys_addr));
 
-- 
2.7.0


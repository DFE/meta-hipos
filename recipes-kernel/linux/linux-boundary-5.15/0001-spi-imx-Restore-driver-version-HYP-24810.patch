From 1f45f83dd051d3b7971fe21995e78766f845561c Mon Sep 17 00:00:00 2001
From: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date: Wed, 22 Sep 2021 18:57:47 +0200
Subject: [PATCH] spi-imx: Restore driver version HYP-24810

Current spi-imx driver version from kernel 5.10.69 does not work with
'spi-reg' tool. Therefore the driver version from kernel 4.14.98 is
restored.

Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
---
 drivers/spi/spi-imx.c | 515 +++++++++++++-----------------------------
 1 file changed, 155 insertions(+), 360 deletions(-)

diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c
index 425be026ab35..0e3bc0b0a526 100644
--- a/drivers/spi/spi-imx.c
+++ b/drivers/spi/spi-imx.c
@@ -33,7 +33,6 @@ module_param(use_dma, bool, 0644);
 MODULE_PARM_DESC(use_dma, "Enable usage of DMA when available (default)");
 
 #define MXC_RPM_TIMEOUT		2000 /* 2000ms */
-#define MXC_SPI_DEFAULT_SPEED	500000 /* 500KHz */
 
 #define MXC_CSPIRXDATA		0x00
 #define MXC_CSPITXDATA		0x04
@@ -45,11 +44,12 @@ MODULE_PARM_DESC(use_dma, "Enable usage of DMA when available (default)");
 #define MXC_INT_RR	(1 << 0) /* Receive data ready interrupt */
 #define MXC_INT_TE	(1 << 1) /* Transmit FIFO empty interrupt */
 #define MXC_INT_RDR	BIT(4) /* Receive date threshold interrupt */
-#define MXC_INT_TCEN    BIT(7)	/* Transfer complete */
 
 /* The maximum bytes that a sdma BD can transfer. */
 #define MAX_SDMA_BD_BYTES (1 << 15)
 #define MX51_ECSPI_CTRL_MAX_BURST	512
+/* The maximum bytes that IMX53_ECSPI can transfer in slave mode.*/
+#define MX53_MAX_TRANSFER_BYTES		512
 
 enum spi_imx_devtype {
 	IMX1_CSPI,
@@ -59,7 +59,6 @@ enum spi_imx_devtype {
 	IMX35_CSPI,	/* CSPI on all i.mx except above */
 	IMX51_ECSPI,	/* ECSPI on i.mx51 */
 	IMX53_ECSPI,	/* ECSPI on i.mx53 and later */
-	IMX6UL_ECSPI,	/* ERR009165 fix from i.mx6ul */
 };
 
 struct spi_imx_data;
@@ -74,16 +73,11 @@ struct spi_imx_devtype_data {
 	void (*setup_wml)(struct spi_imx_data *);
 	void (*disable)(struct spi_imx_data *);
 	void (*disable_dma)(struct spi_imx_data *);
+	bool has_dmamode;
 	bool has_slavemode;
 	unsigned int fifo_size;
 	bool dynamic_burst;
 	enum spi_imx_devtype devtype;
-#define QUIRK_HAS_LOOP		1
-#define QUIRK_HAS_READY		2
-#define QUIRK_HAS_DMA		4
-#define QUIRK_ERR009165		8
-	int quirks;
-	int max_slave_transfer_bytes;
 };
 
 struct spi_imx_data {
@@ -99,10 +93,7 @@ struct spi_imx_data {
 	unsigned long spi_clk;
 	unsigned int spi_bus_clk;
 
-	unsigned int speed_hz;
 	unsigned int bits_per_word;
-	unsigned int len;
-	unsigned int prev_width;
 	unsigned int spi_drctl;
 
 	unsigned int count, remainder;
@@ -123,17 +114,10 @@ struct spi_imx_data {
 	u32 wml;
 	struct completion dma_rx_completion;
 	struct completion dma_tx_completion;
-	struct dma_slave_config rx_config;
-	struct dma_slave_config tx_config;
 
 	const struct spi_imx_devtype_data *devtype_data;
 };
 
-static inline int cspi_quirk(struct spi_imx_data *d, int quirk_mask)
-{
-	return d->devtype_data->quirks & quirk_mask;
-}
-
 static inline int is_imx27_cspi(struct spi_imx_data *d)
 {
 	return d->devtype_data->devtype == IMX27_CSPI;
@@ -144,14 +128,14 @@ static inline int is_imx35_cspi(struct spi_imx_data *d)
 	return d->devtype_data->devtype == IMX35_CSPI;
 }
 
-static inline int is_imx53_ecspi(struct spi_imx_data *d)
+static inline int is_imx51_ecspi(struct spi_imx_data *d)
 {
-	return d->devtype_data->devtype == IMX53_ECSPI;
+	return d->devtype_data->devtype == IMX51_ECSPI;
 }
 
-static inline unsigned spi_imx_get_fifosize(struct spi_imx_data *d)
+static inline int is_imx53_ecspi(struct spi_imx_data *d)
 {
-	return d->devtype_data->fifo_size;
+	return d->devtype_data->devtype == IMX53_ECSPI;
 }
 
 #define MXC_SPI_BUF_RX(type)						\
@@ -240,7 +224,6 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 			 struct spi_transfer *transfer)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
-	int bytes_per_word;
 
 	if (!use_dma || master->fallback)
 		return false;
@@ -251,11 +234,12 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 	if (spi_imx->slave_mode)
 		return false;
 
-	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
+	if (transfer->len < spi_imx->devtype_data->fifo_size)
+		return false;
+
 	spi_imx->dynamic_burst = 0;
-	if (transfer->len > spi_imx_get_fifosize(spi_imx) * bytes_per_word)
-		return true;
-	return false;
+
+	return true;
 }
 
 #define MX51_ECSPI_CTRL		0x08
@@ -266,22 +250,21 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_CTRL_DRCTL(drctl)	((drctl) << 16)
 #define MX51_ECSPI_CTRL_POSTDIV_OFFSET	8
 #define MX51_ECSPI_CTRL_PREDIV_OFFSET	12
-#define MX51_ECSPI_CTRL_CS(cs)		(((cs) & 3) << 18)
+#define MX51_ECSPI_CTRL_CS(cs)		((cs) << 18)
 #define MX51_ECSPI_CTRL_BL_OFFSET	20
 #define MX51_ECSPI_CTRL_BL_MASK		(0xfff << 20)
 
 #define MX51_ECSPI_CONFIG	0x0c
-#define MX51_ECSPI_CONFIG_SCLKPHA(cs)	(1 << (((cs) & 3) +  0))
-#define MX51_ECSPI_CONFIG_SCLKPOL(cs)	(1 << (((cs) & 3) +  4))
-#define MX51_ECSPI_CONFIG_SBBCTRL(cs)	(1 << (((cs) & 3) +  8))
-#define MX51_ECSPI_CONFIG_SSBPOL(cs)	(1 << (((cs) & 3) + 12))
-#define MX51_ECSPI_CONFIG_SCLKCTL(cs)	(1 << (((cs) & 3) + 20))
+#define MX51_ECSPI_CONFIG_SCLKPHA(cs)	(1 << ((cs) +  0))
+#define MX51_ECSPI_CONFIG_SCLKPOL(cs)	(1 << ((cs) +  4))
+#define MX51_ECSPI_CONFIG_SBBCTRL(cs)	(1 << ((cs) +  8))
+#define MX51_ECSPI_CONFIG_SSBPOL(cs)	(1 << ((cs) + 12))
+#define MX51_ECSPI_CONFIG_SCLKCTL(cs)	(1 << ((cs) + 20))
 
 #define MX51_ECSPI_INT		0x10
 #define MX51_ECSPI_INT_TEEN		(1 <<  0)
 #define MX51_ECSPI_INT_RREN		(1 <<  3)
 #define MX51_ECSPI_INT_RDREN		(1 <<  4)
-#define MX51_ECSPI_INT_TCEN             (1 << 7)
 
 #define MX51_ECSPI_DMA		0x14
 #define MX51_ECSPI_DMA_TX_WML(wml)	((wml) & 0x3f)
@@ -295,8 +278,6 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_STAT		0x18
 #define MX51_ECSPI_STAT_RR		(1 <<  3)
 
-#define MX51_ECSPI_PERIOD		0x1c
-
 #define MX51_ECSPI_TESTREG	0x20
 #define MX51_ECSPI_TESTREG_LBC	BIT(31)
 
@@ -404,12 +385,7 @@ static void spi_imx_buf_tx_swap(struct spi_imx_data *spi_imx)
 
 static void mx53_ecspi_rx_slave(struct spi_imx_data *spi_imx)
 {
-	u32 val = readl(spi_imx->base + MXC_CSPIRXDATA);
-
-	if (spi_imx->bits_per_word <= 8)
-		val = be32_to_cpu(val);
-	else if (spi_imx->bits_per_word <= 16)
-		val = (val << 16) | (val >> 16);
+	u32 val = be32_to_cpu(readl(spi_imx->base + MXC_CSPIRXDATA));
 
 	if (spi_imx->rx_buf) {
 		int n_bytes = spi_imx->slave_burst % sizeof(val);
@@ -438,11 +414,7 @@ static void mx53_ecspi_tx_slave(struct spi_imx_data *spi_imx)
 	if (spi_imx->tx_buf) {
 		memcpy(((u8 *)&val) + sizeof(val) - n_bytes,
 		       spi_imx->tx_buf, n_bytes);
-		if (spi_imx->bits_per_word <= 8)
-			val = cpu_to_be32(val);
-		else if (spi_imx->bits_per_word <= 16)
-			val = (val << 16) | (val >> 16);
-
+		val = cpu_to_be32(val);
 		spi_imx->tx_buf += n_bytes;
 	}
 
@@ -502,8 +474,6 @@ static void mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)
 
 	if (enable & MXC_INT_RDR)
 		val |= MX51_ECSPI_INT_RDREN;
-	if (enable & MXC_INT_TCEN)
-		val |= MX51_ECSPI_INT_TCEN;
 
 	writel(val, spi_imx->base + MX51_ECSPI_INT);
 }
@@ -556,13 +526,6 @@ static int mx51_ecspi_prepare_message(struct spi_imx_data *spi_imx,
 	/* set chip select to use */
 	ctrl |= MX51_ECSPI_CTRL_CS(spi->chip_select);
 
-	/*
-	 * To workaround ERR009165, SDMA script needs to use XCH instead of SMC
-	 * just like PIO mode and it is fixed on i.mx6ul
-	 */
-	if (spi_imx->usedma && !cspi_quirk(spi_imx, QUIRK_ERR009165))
-		ctrl |= MX51_ECSPI_CTRL_SMC;
-
 	/*
 	 * The ctrl register must be written first, with the EN bit set other
 	 * registers must not be written to.
@@ -581,7 +544,7 @@ static int mx51_ecspi_prepare_message(struct spi_imx_data *spi_imx,
 	 * is not functional for imx53 Soc, config SPI burst completed when
 	 * BURST_LENGTH + 1 bits are received
 	 */
-	if (spi_imx->slave_mode)
+	if (spi_imx->slave_mode && is_imx53_ecspi(spi_imx))
 		cfg &= ~MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
 	else
 		cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
@@ -643,49 +606,24 @@ static int mx51_ecspi_prepare_transfer(struct spi_imx_data *spi_imx,
 {
 	u32 ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);
 	u32 clk;
-	u32 bits = spi_imx->bits_per_word;
 
 	/* Clear BL field and set the right value */
 	ctrl &= ~MX51_ECSPI_CTRL_BL_MASK;
-	if (spi_imx->slave_mode) {
-		bits = spi_imx->slave_burst * 8;
-	} else {
-		if (bits == 32) {
-			unsigned len = spi_imx->len / 4;
-
-			while (len > 128) {
-				if (len & 1)
-					break;
-				len >>= 1;
-			}
-			while (len > 128) {
-				if (len % 3)
-					break;
-				len /= 3;
-			}
-			if ((len > 128) || !len)
-				len = 1;
-			bits = len << 5;
-		}
-	}
-	ctrl |= (bits - 1) << MX51_ECSPI_CTRL_BL_OFFSET;
+	if (spi_imx->slave_mode && is_imx53_ecspi(spi_imx))
+		ctrl |= (spi_imx->slave_burst * 8 - 1)
+			<< MX51_ECSPI_CTRL_BL_OFFSET;
+	else
+		ctrl |= (spi_imx->bits_per_word - 1)
+			<< MX51_ECSPI_CTRL_BL_OFFSET;
 
 	/* set clock speed */
 	ctrl &= ~(0xf << MX51_ECSPI_CTRL_POSTDIV_OFFSET |
 		  0xf << MX51_ECSPI_CTRL_PREDIV_OFFSET);
-	if (!spi_imx->slave_mode) {
-		ctrl |= mx51_ecspi_clkdiv(spi_imx, spi_imx->spi_bus_clk, &clk);
-		spi_imx->spi_bus_clk = clk;
-	}
+	ctrl |= mx51_ecspi_clkdiv(spi_imx, spi_imx->spi_bus_clk, &clk);
+	spi_imx->spi_bus_clk = clk;
 
-	/*
-	 * ERR009165: work in XHC mode instead of SMC as PIO on the chips
-	 * before i.mx6ul.
-	 */
-	if (spi_imx->usedma && !cspi_quirk(spi_imx, QUIRK_ERR009165))
+	if (spi_imx->usedma)
 		ctrl |= MX51_ECSPI_CTRL_SMC;
-	else
-		ctrl &= ~MX51_ECSPI_CTRL_SMC;
 
 	writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
 
@@ -694,24 +632,15 @@ static int mx51_ecspi_prepare_transfer(struct spi_imx_data *spi_imx,
 
 static void mx51_setup_wml(struct spi_imx_data *spi_imx)
 {
-	u32 tx_wml;
-
-	/*
-	 * work around for
-	 * ERR009165 eCSPI: TXFIFO empty flag glitch can cause the current
-	 * FIFO transfer to be sent twice
-	 */
-	tx_wml = !cspi_quirk(spi_imx, QUIRK_ERR009165) ?
-		spi_imx_get_fifosize(spi_imx) - spi_imx->tx_config.dst_maxburst :
-		0;
-
 	/*
 	 * Configure the DMA register: setup the watermark
 	 * and enable DMA request.
 	 */
 	writel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml - 1) |
-		MX51_ECSPI_DMA_TX_WML(tx_wml),
-		spi_imx->base + MX51_ECSPI_DMA);
+		MX51_ECSPI_DMA_TX_WML(spi_imx->wml) |
+		MX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |
+		MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |
+		MX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);
 }
 
 static int mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)
@@ -790,11 +719,9 @@ static int mx31_prepare_transfer(struct spi_imx_data *spi_imx,
 	unsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	if (!spi_imx->slave_mode) {
-		reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<
-			MX31_CSPICTRL_DR_SHIFT;
-		spi_imx->spi_bus_clk = clk;
-	}
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<
+		MX31_CSPICTRL_DR_SHIFT;
+	spi_imx->spi_bus_clk = clk;
 
 	if (is_imx35_cspi(spi_imx)) {
 		reg |= (spi_imx->bits_per_word - 1) << MX35_CSPICTRL_BL_SHIFT;
@@ -897,11 +824,9 @@ static int mx21_prepare_transfer(struct spi_imx_data *spi_imx,
 	unsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;
 	unsigned int clk;
 
-	if (!spi_imx->slave_mode) {
-		reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, spi_imx->spi_bus_clk, max, &clk)
-			<< MX21_CSPICTRL_DR_SHIFT;
-		spi_imx->spi_bus_clk = clk;
-	}
+	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, spi_imx->spi_bus_clk, max, &clk)
+		<< MX21_CSPICTRL_DR_SHIFT;
+	spi_imx->spi_bus_clk = clk;
 
 	reg |= spi_imx->bits_per_word - 1;
 
@@ -973,11 +898,9 @@ static int mx1_prepare_transfer(struct spi_imx_data *spi_imx,
 	unsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	if (!spi_imx->slave_mode) {
-		reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<
-			MX1_CSPICTRL_DR_SHIFT;
-		spi_imx->spi_bus_clk = clk;
-	}
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->spi_bus_clk, &clk) <<
+		MX1_CSPICTRL_DR_SHIFT;
+	spi_imx->spi_bus_clk = clk;
 
 	reg |= spi_imx->bits_per_word - 1;
 
@@ -1009,6 +932,7 @@ static struct spi_imx_devtype_data imx1_cspi_devtype_data = {
 	.rx_available = mx1_rx_available,
 	.reset = mx1_reset,
 	.fifo_size = 8,
+	.has_dmamode = false,
 	.dynamic_burst = false,
 	.has_slavemode = false,
 	.devtype = IMX1_CSPI,
@@ -1022,6 +946,7 @@ static struct spi_imx_devtype_data imx21_cspi_devtype_data = {
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
 	.fifo_size = 8,
+	.has_dmamode = false,
 	.dynamic_burst = false,
 	.has_slavemode = false,
 	.devtype = IMX21_CSPI,
@@ -1036,6 +961,7 @@ static struct spi_imx_devtype_data imx27_cspi_devtype_data = {
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
 	.fifo_size = 8,
+	.has_dmamode = false,
 	.dynamic_burst = false,
 	.has_slavemode = false,
 	.devtype = IMX27_CSPI,
@@ -1049,6 +975,7 @@ static struct spi_imx_devtype_data imx31_cspi_devtype_data = {
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
 	.fifo_size = 8,
+	.has_dmamode = false,
 	.dynamic_burst = false,
 	.has_slavemode = false,
 	.devtype = IMX31_CSPI,
@@ -1063,10 +990,10 @@ static struct spi_imx_devtype_data imx35_cspi_devtype_data = {
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
 	.fifo_size = 8,
+	.has_dmamode = true,
 	.dynamic_burst = false,
 	.has_slavemode = false,
 	.devtype = IMX35_CSPI,
-	.quirks = QUIRK_HAS_LOOP | QUIRK_HAS_READY | QUIRK_HAS_DMA | QUIRK_ERR009165,
 };
 
 static struct spi_imx_devtype_data imx51_ecspi_devtype_data = {
@@ -1079,12 +1006,11 @@ static struct spi_imx_devtype_data imx51_ecspi_devtype_data = {
 	.setup_wml = mx51_setup_wml,
 	.disable_dma = mx51_disable_dma,
 	.fifo_size = 64,
+	.has_dmamode = true,
 	.dynamic_burst = true,
 	.has_slavemode = true,
 	.disable = mx51_ecspi_disable,
 	.devtype = IMX51_ECSPI,
-	.quirks = QUIRK_HAS_LOOP | QUIRK_HAS_READY | QUIRK_HAS_DMA | QUIRK_ERR009165,
-	.max_slave_transfer_bytes = 512,
 };
 
 static struct spi_imx_devtype_data imx53_ecspi_devtype_data = {
@@ -1095,30 +1021,11 @@ static struct spi_imx_devtype_data imx53_ecspi_devtype_data = {
 	.rx_available = mx51_ecspi_rx_available,
 	.disable_dma = mx51_disable_dma,
 	.reset = mx51_ecspi_reset,
-	.setup_wml = mx51_setup_wml,
 	.fifo_size = 64,
-	.dynamic_burst = true,
+	.has_dmamode = true,
 	.has_slavemode = true,
 	.disable = mx51_ecspi_disable,
 	.devtype = IMX53_ECSPI,
-	.quirks = QUIRK_HAS_LOOP | QUIRK_HAS_READY | QUIRK_HAS_DMA,
-	.max_slave_transfer_bytes = 512,
-};
-
-static struct spi_imx_devtype_data imx6ul_ecspi_devtype_data = {
-	.intctrl = mx51_ecspi_intctrl,
-	.prepare_message = mx51_ecspi_prepare_message,
-	.prepare_transfer = mx51_ecspi_prepare_transfer,
-	.trigger = mx51_ecspi_trigger,
-	.rx_available = mx51_ecspi_rx_available,
-	.reset = mx51_ecspi_reset,
-	.setup_wml = mx51_setup_wml,
-	.fifo_size = 64,
-	.dynamic_burst = true,
-	.has_slavemode = true,
-	.disable = mx51_ecspi_disable,
-	.devtype = IMX6UL_ECSPI,
-	.quirks = QUIRK_HAS_LOOP | QUIRK_HAS_READY | QUIRK_HAS_DMA,
 };
 
 static const struct platform_device_id spi_imx_devtype[] = {
@@ -1143,9 +1050,6 @@ static const struct platform_device_id spi_imx_devtype[] = {
 	}, {
 		.name = "imx53-ecspi",
 		.driver_data = (kernel_ulong_t) &imx53_ecspi_devtype_data,
-	}, {
-		.name = "imx6ul-ecspi",
-		.driver_data = (kernel_ulong_t) &imx6ul_ecspi_devtype_data,
 	}, {
 		/* sentinel */
 	}
@@ -1159,7 +1063,6 @@ static const struct of_device_id spi_imx_dt_ids[] = {
 	{ .compatible = "fsl,imx35-cspi", .data = &imx35_cspi_devtype_data, },
 	{ .compatible = "fsl,imx51-ecspi", .data = &imx51_ecspi_devtype_data, },
 	{ .compatible = "fsl,imx53-ecspi", .data = &imx53_ecspi_devtype_data, },
-	{ .compatible = "fsl,imx6ul-ecspi", .data = &imx6ul_ecspi_devtype_data, },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, spi_imx_dt_ids);
@@ -1249,11 +1152,54 @@ static irqreturn_t spi_imx_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static int spi_imx_dma_configure(struct spi_master *master)
+{
+	int ret;
+	enum dma_slave_buswidth buswidth;
+	struct dma_slave_config rx = {}, tx = {};
+	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
+
+	switch (spi_imx_bytes_per_word(spi_imx->bits_per_word)) {
+	case 4:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	case 2:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 1:
+		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tx.direction = DMA_MEM_TO_DEV;
+	tx.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;
+	tx.dst_addr_width = buswidth;
+	tx.dst_maxburst = spi_imx->wml;
+	ret = dmaengine_slave_config(master->dma_tx, &tx);
+	if (ret) {
+		dev_err(spi_imx->dev, "TX dma configuration failed with %d\n", ret);
+		return ret;
+	}
+
+	rx.direction = DMA_DEV_TO_MEM;
+	rx.src_addr = spi_imx->base_phys + MXC_CSPIRXDATA;
+	rx.src_addr_width = buswidth;
+	rx.src_maxburst = spi_imx->wml;
+	ret = dmaengine_slave_config(master->dma_rx, &rx);
+	if (ret) {
+		dev_err(spi_imx->dev, "RX dma configuration failed with %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int spi_imx_setupxfer(struct spi_device *spi,
 				 struct spi_transfer *t)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
-	int bits_per_word;
 
 	if (!t)
 		return 0;
@@ -1268,15 +1214,7 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 	} else
 		spi_imx->spi_bus_clk = t->speed_hz;
 
-	if (spi_imx_can_dma(spi_imx->bitbang.master, spi, t))
-		spi_imx->usedma = true;
-	else
-		spi_imx->usedma = false;
-
-	bits_per_word = t->bits_per_word;
-	spi_imx->bits_per_word = bits_per_word;
-	spi_imx->speed_hz  = t->speed_hz;
-	spi_imx->len  = t->len;
+	spi_imx->bits_per_word = t->bits_per_word;
 
 	/*
 	 * Initialize the functions for transfer. To transfer non byte-aligned
@@ -1293,10 +1231,10 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 		spi_imx->dynamic_burst = 1;
 
 	} else {
-		if (bits_per_word <= 8) {
+		if (spi_imx->bits_per_word <= 8) {
 			spi_imx->rx = spi_imx_buf_rx_u8;
 			spi_imx->tx = spi_imx_buf_tx_u8;
-		} else if (bits_per_word <= 16) {
+		} else if (spi_imx->bits_per_word <= 16) {
 			spi_imx->rx = spi_imx_buf_rx_u16;
 			spi_imx->tx = spi_imx_buf_tx_u16;
 		} else {
@@ -1306,7 +1244,12 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 		spi_imx->dynamic_burst = 0;
 	}
 
-	if (spi_imx->slave_mode) {
+	if (spi_imx_can_dma(spi_imx->bitbang.master, spi, t))
+		spi_imx->usedma = true;
+	else
+		spi_imx->usedma = false;
+
+	if (is_imx53_ecspi(spi_imx) && spi_imx->slave_mode) {
 		spi_imx->rx = mx53_ecspi_rx_slave;
 		spi_imx->tx = mx53_ecspi_tx_slave;
 		spi_imx->slave_burst = t->len;
@@ -1336,26 +1279,22 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 			     struct spi_master *master)
 {
 	int ret;
-	int fifosize = spi_imx_get_fifosize(spi_imx);
 
-	spi_imx->wml = fifosize / 2;
+	/* use pio mode for i.mx6dl chip TKT238285 */
+	if (of_machine_is_compatible("fsl,imx6dl"))
+		return 0;
+
+	spi_imx->wml = spi_imx->devtype_data->fifo_size / 2;
 
 	/* Prepare for TX DMA: */
 	master->dma_tx = dma_request_chan(dev, "tx");
 	if (IS_ERR(master->dma_tx)) {
 		ret = PTR_ERR(master->dma_tx);
+		dev_dbg(dev, "can't get the TX DMA channel, error %d!\n", ret);
 		master->dma_tx = NULL;
-		if (ret == -EPROBE_DEFER)
-			return ret;
-		dev_err(dev, "can't get the TX DMA channel, error %d!\n", ret);
-		return ret;
+		goto err;
 	}
 
-	spi_imx->tx_config.direction = DMA_MEM_TO_DEV;
-	spi_imx->tx_config.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;
-	spi_imx->tx_config.dst_maxburst = (!cspi_quirk(spi_imx, QUIRK_ERR009165) ||
-		(spi_imx->speed_hz > 40000000)) ? spi_imx->wml : fifosize;
-
 	/* Prepare for RX : */
 	master->dma_rx = dma_request_chan(dev, "rx");
 	if (IS_ERR(master->dma_rx)) {
@@ -1365,9 +1304,6 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 		goto err;
 	}
 
-	spi_imx->rx_config.direction = DMA_DEV_TO_MEM;
-	spi_imx->rx_config.src_addr = spi_imx->base_phys + MXC_CSPIRXDATA;
-	spi_imx->rx_config.src_maxburst = spi_imx->wml;
 	init_completion(&spi_imx->dma_rx_completion);
 	init_completion(&spi_imx->dma_tx_completion);
 	master->can_dma = spi_imx_can_dma;
@@ -1375,18 +1311,6 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 	spi_imx->bitbang.master->flags = SPI_MASTER_MUST_RX |
 					 SPI_MASTER_MUST_TX;
 
-
-	/*
-	 * I have no idea why this is needed, but a dma error
-	 * happens on 1st dma without it
-	 */
-	spi_imx->tx_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-	ret = dmaengine_slave_config(spi_imx->bitbang.master->dma_tx,
-			&spi_imx->tx_config);
-	if (ret) {
-		dev_err(spi_imx->dev, "error(%d) in TX dma configuration.\n", ret);
-		goto err;
-	}
 	return 0;
 err:
 	spi_imx_sdma_exit(spi_imx);
@@ -1407,41 +1331,18 @@ static void spi_imx_dma_tx_callback(void *cookie)
 	complete(&spi_imx->dma_tx_completion);
 }
 
-static void spi_imx_tail_pio_set(struct spi_imx_data *spi_imx, int left)
-{
-
-	switch (spi_imx->rx_config.src_addr_width) {
-	case DMA_SLAVE_BUSWIDTH_1_BYTE:
-		spi_imx->rx = spi_imx_buf_rx_u8;
-		break;
-	case DMA_SLAVE_BUSWIDTH_2_BYTES:
-		spi_imx->rx = spi_imx_buf_rx_u16;
-		break;
-	case DMA_SLAVE_BUSWIDTH_4_BYTES:
-		spi_imx->rx = spi_imx_buf_rx_u32;
-		break;
-	default:
-		spi_imx->rx = spi_imx_buf_rx_u8;
-		break;
-	}
-
-	spi_imx->txfifo = left / spi_imx->rx_config.src_addr_width;
-}
-
 static int spi_imx_calculate_timeout(struct spi_imx_data *spi_imx, int size)
 {
-	uint64_t timeout = 0;
+	unsigned long timeout = 0;
 
 	/* Time with actual data transfer and CS change delay related to HW */
-	timeout = ((8 + 4) * size);
-	timeout *= MSEC_PER_SEC;
-	do_div(timeout, spi_imx->spi_bus_clk);
+	timeout = (8 + 4) * size / spi_imx->spi_bus_clk;
 
 	/* Add extra second for scheduler related activities */
-	timeout += MSEC_PER_SEC;
+	timeout += 1;
 
 	/* Double calculated timeout */
-	return msecs_to_jiffies(timeout * 2);
+	return msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);
 }
 
 static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
@@ -1449,54 +1350,28 @@ static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
 {
 	struct dma_async_tx_descriptor *desc_tx, *desc_rx;
 	unsigned long transfer_timeout;
-	int left = 0;
+	unsigned long timeout;
 	struct spi_master *master = spi_imx->bitbang.master;
 	struct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;
-	int bits_per_word = transfer->bits_per_word;
-	int burst;
-	int width;
+	struct scatterlist *last_sg = sg_last(rx->sgl, rx->nents);
+	unsigned int bytes_per_word, i;
 	int ret;
-	unsigned nents;
-	int rem;
-	u32 bpw;
-	u32 reg;
 
-	if (bits_per_word <= 8) {
-		width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-	} else if (bits_per_word <= 16) {
-		width = DMA_SLAVE_BUSWIDTH_2_BYTES;
-	} else {
-		width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	/* Get the right burst length from the last sg to ensure no tail data */
+	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
+	for (i = spi_imx->devtype_data->fifo_size / 2; i > 0; i--) {
+		if (!(sg_dma_len(last_sg) % (i * bytes_per_word)))
+			break;
 	}
-	/*
-	 * Try to improve performance for workaround
-	 * ERR009165 eCSPI: TXFIFO empty flag glitch can cause the current
-	 * FIFO transfer to be sent twice
-	 */
-	burst = (!cspi_quirk(spi_imx, QUIRK_ERR009165) || (spi_imx->speed_hz > 40000000)) ?
-			spi_imx->wml : spi_imx_get_fifosize(spi_imx);
-	spi_imx->rx_config.src_addr_width = width;
-	spi_imx->tx_config.dst_addr_width = width;
-
-	if (spi_imx->usedma && (spi_imx->prev_width != width ||
-			spi_imx->tx_config.dst_maxburst != burst)) {
-		spi_imx->prev_width = width;
-		spi_imx->tx_config.dst_maxburst = burst;
-
-		ret = dmaengine_slave_config(spi_imx->bitbang.master->dma_rx,
-						&spi_imx->rx_config);
-		if (ret) {
-			dev_err(spi_imx->dev, "error in RX dma configuration.\n");
-			goto dma_failure_no_start;
-		}
+	/* Use 1 as wml in case no available burst length got */
+	if (i == 0)
+		i = 1;
 
-		ret = dmaengine_slave_config(spi_imx->bitbang.master->dma_tx,
-						&spi_imx->tx_config);
-		if (ret) {
-			dev_err(spi_imx->dev, "error in TX dma configuration.\n");
-			goto dma_failure_no_start;
-		}
-	}
+	spi_imx->wml =  i;
+
+	ret = spi_imx_dma_configure(master);
+	if (ret)
+		goto dma_failure_no_start;
 
 	if (!spi_imx->devtype_data->setup_wml) {
 		dev_err(spi_imx->dev, "No setup_wml()?\n");
@@ -1505,32 +1380,6 @@ static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
 	}
 	spi_imx->devtype_data->setup_wml(spi_imx);
 
-	nents = rx->nents;
-	bpw = spi_imx->rx_config.src_addr_width;
-	/*
-	 * Adjust the transfer lenth of the last scattlist if there are
-	 * some tail data, use PIO read to get the tail data since DMA
-	 * sometimes miss the last tail interrupt.
-	 */
-	left = rem = transfer->len % (spi_imx->rx_config.src_maxburst * bpw);
-	while (rem) {
-		struct scatterlist *sgl_last = &rx->sgl[nents - 1];
-
-		if (sgl_last->length > rem) {
-			sgl_last->length -= rem;
-#ifdef CONFIG_NEED_SG_DMA_LENGTH
-			sgl_last->dma_length = sgl_last->length;
-#endif
-			break;
-		}
-		rem -= sgl_last->length;
-		sgl_last->length = 0;
-#ifdef CONFIG_NEED_SG_DMA_LENGTH
-		sgl_last->dma_length = 0;
-#endif
-		nents--;
-		rx->nents--;
-	}
 	/*
 	 * The TX DMA setup starts the transfer, so make sure RX is configured
 	 * before TX.
@@ -1545,79 +1394,46 @@ static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
 
 	desc_rx->callback = spi_imx_dma_rx_callback;
 	desc_rx->callback_param = (void *)spi_imx;
+	dmaengine_submit(desc_rx);
 	reinit_completion(&spi_imx->dma_rx_completion);
+	dma_async_issue_pending(master->dma_rx);
 
 	desc_tx = dmaengine_prep_slave_sg(master->dma_tx,
 				tx->sgl, tx->nents, DMA_MEM_TO_DEV,
 				DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-	if (!desc_tx)
+	if (!desc_tx) {
+		dmaengine_terminate_all(master->dma_tx);
+		dmaengine_terminate_all(master->dma_rx);
 		return -EINVAL;
+	}
 
 	desc_tx->callback = spi_imx_dma_tx_callback;
 	desc_tx->callback_param = (void *)spi_imx;
-	reinit_completion(&spi_imx->dma_tx_completion);
-
-	dmaengine_submit(desc_rx);
-	dma_async_issue_pending(master->dma_rx);
-
 	dmaengine_submit(desc_tx);
+	reinit_completion(&spi_imx->dma_tx_completion);
 	dma_async_issue_pending(master->dma_tx);
 
 	transfer_timeout = spi_imx_calculate_timeout(spi_imx, transfer->len);
 
-	reg = readl(spi_imx->base + MX51_ECSPI_DMA);
-	reg |= MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN;
-	writel(reg, spi_imx->base + MX51_ECSPI_DMA);
-
 	/* Wait SDMA to finish the data transfer.*/
-	ret = wait_for_completion_timeout(&spi_imx->dma_tx_completion,
-					  transfer_timeout);
-	if (!ret) {
-		dev_err(spi_imx->dev, "I/O Error in DMA TX:%x %x %x %x %x\n",
-				transfer->len,
-				readl(spi_imx->base + MX51_ECSPI_STAT),
-				readl(spi_imx->base + MX51_ECSPI_TESTREG),
-				readl(spi_imx->base + MX51_ECSPI_DMA),
-				readl(spi_imx->base + MX51_ECSPI_CTRL));
+	timeout = wait_for_completion_timeout(&spi_imx->dma_tx_completion,
+						transfer_timeout);
+	if (!timeout) {
+		dev_err(spi_imx->dev, "I/O Error in DMA TX\n");
 		dmaengine_terminate_all(master->dma_tx);
 		dmaengine_terminate_all(master->dma_rx);
 		return -ETIMEDOUT;
 	}
 
-	ret = wait_for_completion_timeout(&spi_imx->dma_rx_completion,
-			transfer_timeout);
-	if (!ret) {
-		dev_err(spi_imx->dev, "I/O Error in DMA RX:%x %x %x\n",
-			transfer->len,
-			readl(spi_imx->base + MX51_ECSPI_STAT),
-			readl(spi_imx->base + MX51_ECSPI_TESTREG));
+	timeout = wait_for_completion_timeout(&spi_imx->dma_rx_completion,
+					      transfer_timeout);
+	if (!timeout) {
+		dev_err(&master->dev, "I/O Error in DMA RX\n");
 		spi_imx->devtype_data->reset(spi_imx);
 		dmaengine_terminate_all(master->dma_rx);
 		return -ETIMEDOUT;
 	}
 
-	if (left) {
-		/* read the tail data by PIO */
-		dma_sync_sg_for_cpu(master->dma_rx->device->dev,
-				    &rx->sgl[rx->nents - 1], 1,
-				    DMA_FROM_DEVICE);
-		spi_imx->rx_buf = transfer->rx_buf
-					+ (transfer->len - left);
-		spi_imx_tail_pio_set(spi_imx, left);
-		reinit_completion(&spi_imx->xfer_done);
-
-		spi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TCEN | MXC_INT_RR);
-
-		ret = wait_for_completion_timeout(&spi_imx->xfer_done,
-					transfer_timeout);
-		if (!ret) {
-			dev_err(spi_imx->dev, "I/O Error in RX tail len=%d left=%d txfifo=%d width=%d\n",
-				transfer->len, left, spi_imx->txfifo, spi_imx->rx_config.src_addr_width);
-
-			return -ETIMEDOUT;
-		}
-	}
-
 	return transfer->len;
 /* fallback to pio */
 dma_failure_no_start:
@@ -1662,11 +1478,11 @@ static int spi_imx_pio_transfer_slave(struct spi_device *spi,
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	int ret = transfer->len;
-	int max = spi_imx->devtype_data->max_slave_transfer_bytes;
 
-	if (max && transfer->len > max) {
+	if (is_imx53_ecspi(spi_imx) &&
+	    transfer->len > MX53_MAX_TRANSFER_BYTES) {
 		dev_err(&spi->dev, "Transaction too big, max size is %d bytes\n",
-			max);
+			MX53_MAX_TRANSFER_BYTES);
 		return -EMSGSIZE;
 	}
 
@@ -1706,6 +1522,8 @@ static int spi_imx_transfer(struct spi_device *spi,
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 
+	transfer->effective_speed_hz = spi_imx->spi_bus_clk;
+
 	/* flush rxfifo before transfer */
 	while (spi_imx->devtype_data->rx_available(spi_imx))
 		readl(spi_imx->base + MXC_CSPIRXDATA);
@@ -1713,8 +1531,6 @@ static int spi_imx_transfer(struct spi_device *spi,
 	if (spi_imx->slave_mode)
 		return spi_imx_pio_transfer_slave(spi, transfer);
 
-	transfer->effective_speed_hz = spi_imx->spi_bus_clk;
-
 	if (spi_imx->usedma)
 		return spi_imx_dma_transfer(spi_imx, transfer);
 
@@ -1775,22 +1591,6 @@ static int spi_imx_slave_abort(struct spi_master *master)
 	return 0;
 }
 
-static int get_default_speed(struct device_node *np)
-{
-	struct device_node *nc;
-	int speed_hz;
-
-	if (np) {
-		for_each_available_child_of_node(np, nc) {
-			int ret = of_property_read_u32(nc, "spi-max-frequency", &speed_hz);
-
-			if (ret >= 0)
-				return speed_hz;
-		}
-	}
-	return 20000000;
-}
-
 static int spi_imx_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1800,7 +1600,6 @@ static int spi_imx_probe(struct platform_device *pdev)
 	struct spi_imx_data *spi_imx;
 	struct resource *res;
 	int ret, irq, spi_drctl;
-	u32 speed_hz;
 	const struct spi_imx_devtype_data *devtype_data = of_id ? of_id->data :
 		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
 	bool slave_mode;
@@ -1822,7 +1621,6 @@ static int spi_imx_probe(struct platform_device *pdev)
 		/* '11' is reserved */
 		spi_drctl = 0;
 	}
-	speed_hz = get_default_speed(np);
 
 	platform_set_drvdata(pdev, master);
 
@@ -1834,8 +1632,6 @@ static int spi_imx_probe(struct platform_device *pdev)
 	spi_imx->bitbang.master = master;
 	spi_imx->dev = &pdev->dev;
 	spi_imx->slave_mode = slave_mode;
-	spi_imx->spi_bus_clk = MXC_SPI_DEFAULT_SPEED;
-	spi_imx->speed_hz = speed_hz;
 
 	spi_imx->devtype_data = devtype_data;
 
@@ -1859,10 +1655,9 @@ static int spi_imx_probe(struct platform_device *pdev)
 	spi_imx->bitbang.master->slave_abort = spi_imx_slave_abort;
 	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
 					     | SPI_NO_CS;
-	if (cspi_quirk(spi_imx, QUIRK_HAS_LOOP))
-		spi_imx->bitbang.master->mode_bits |= SPI_LOOP;
-	if (cspi_quirk(spi_imx, QUIRK_HAS_READY))
-		spi_imx->bitbang.master->mode_bits |= SPI_READY;
+	if (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx) ||
+	    is_imx53_ecspi(spi_imx))
+		spi_imx->bitbang.master->mode_bits |= SPI_LOOP | SPI_READY;
 
 	spi_imx->spi_drctl = spi_drctl;
 
@@ -1920,7 +1715,7 @@ static int spi_imx_probe(struct platform_device *pdev)
 	 * Only validated on i.mx35 and i.mx6 now, can remove the constraint
 	 * if validated on other chips.
 	 */
-	if (cspi_quirk(spi_imx, QUIRK_HAS_DMA)) {
+	if (spi_imx->devtype_data->has_dmamode) {
 		ret = spi_imx_sdma_init(&pdev->dev, spi_imx, master);
 		if (ret == -EPROBE_DEFER)
 			goto out_runtime_pm_put;
@@ -1947,7 +1742,7 @@ static int spi_imx_probe(struct platform_device *pdev)
 	return ret;
 
 out_bitbang_start:
-	if (cspi_quirk(spi_imx, QUIRK_HAS_DMA))
+	if (spi_imx->devtype_data->has_dmamode)
 		spi_imx_sdma_exit(spi_imx);
 out_runtime_pm_put:
 	pm_runtime_dont_use_autosuspend(spi_imx->dev);
-- 
2.26.2


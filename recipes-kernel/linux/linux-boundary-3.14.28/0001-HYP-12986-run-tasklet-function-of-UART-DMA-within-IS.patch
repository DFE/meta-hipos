From 18ec2c72281879b0f1b4b07227d0e873c05e059a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ralf=20Schr=C3=B6der?= <schroeder@dresearch-fe.de>
Date: Thu, 12 Nov 2015 14:22:33 +0100
Subject: [PATCH] HYP-12986 run tasklet function of UART DMA within ISR
 directly
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This direct call ensure the correct buffer usage within the
serial driver (imx.c). The handler in imx.c uses also a
tasklet so the ISR performace should be ok.

Signed-off-by: Ralf Schr√∂der <schroeder@dresearch-fe.de>
---
 drivers/dma/imx-sdma.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)
 mode change 100644 => 100755 drivers/dma/imx-sdma.c

diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
old mode 100644
new mode 100755
index bae2ea8..941ed20
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -737,10 +737,15 @@ static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 			(sdmac->peripheral_type != IMX_DMATYPE_HDMI))
 			sdma_update_channel_loop(sdmac);
 
-		spin_lock_irqsave(&sdmac->lock, flags);
-		if (sdmac->status == DMA_IN_PROGRESS || (sdmac->flags & IMX_DMA_SG_LOOP))
-			tasklet_schedule(&sdmac->tasklet);
-		spin_unlock_irqrestore(&sdmac->lock, flags);
+		if (sdmac->peripheral_type != IMX_DMATYPE_UART) {
+			spin_lock_irqsave(&sdmac->lock, flags);
+			if (sdmac->status == DMA_IN_PROGRESS || (sdmac->flags & IMX_DMA_SG_LOOP)) {
+				tasklet_schedule(&sdmac->tasklet);
+			}
+			spin_unlock_irqrestore(&sdmac->lock, flags);
+		} else {
+			sdma_tasklet((unsigned long)sdmac);
+		}
 
 		__clear_bit(channel, &stat);
 	}
-- 
2.1.4


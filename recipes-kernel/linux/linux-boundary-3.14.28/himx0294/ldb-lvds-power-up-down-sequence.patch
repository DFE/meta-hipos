From 783605e6b6981d522c18d81415159154dec1e822 Mon Sep 17 00:00:00 2001
From: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date: Fri, 20 Nov 2015 10:07:00 +0100
Subject: [PATCH] ldb: lvds power up/down sequence

This commit implements a lvds power up and down sequence.
Many lvds displays have a power sequence as follows:

             ___________   _
VCC        _/           \_/
                _____
Data       ____|     |_____
                  _
Backlight _______| |_______

There is a minimum and maximum time requirement between VCC and data and
between data and backlight. To fullfill the time requirements, the ldb driver
needs to know VCC and backlight GPIO and the timing before and after data
enable. Now this can be configured using following "lvds-channel" device tree
elements:

&ldb {
	...
	lvds-channel@0 {
		...
		vcc-gpio = <&gpio4 7 GPIO_ACTIVE_LOW>;
		vcc-powerup-delay-ms = <1>;
		backlight-gpio = <&gpio4 6 GPIO_ACTIVE_HIGH>;
		backlight-powerup-delay-ms = <200>;
		...
	};
};

"vcc-gpio" is the VCC GPIO.
"vcc-powerup-delay-ms" is the delay between VCC and data in milliseconds during
powerup.
"backlight-gpio" is the backlight GPIO.
"backlight-powerup-delay-ms" is the delay between data and backlight in
milliseconds during powerup.

Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
---
 drivers/video/mxc/ldb.c | 98 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 98 insertions(+)

diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index b54d729..8b0a0ed 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -32,6 +32,8 @@
 #include <video/of_videomode.h>
 #include <video/of_display_timing.h>
 #include <video/videomode.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
 #include "mxc_dispdrv.h"
 
 #define DRIVER_NAME	"ldb"
@@ -90,6 +92,12 @@ struct ldb_chan {
 	int chno;
 	bool is_used;
 	bool online;
+	int vcc_gpio;
+	int vcc_active_low;
+	int vcc_powerup_delay_ms;
+	int backlight_gpio;
+	int backlight_active_low;
+	int backlight_powerup_delay_ms;
 };
 
 struct ldb_data {
@@ -563,7 +571,16 @@ static int ldb_enable(struct mxc_dispdrv_handle *mddh,
 					    LDB_CH0_MODE_EN_TO_DI0;
 	}
 
+	if (gpio_is_valid(chan.vcc_gpio)) {
+		gpio_set_value(chan.vcc_gpio, !chan.vcc_active_low);
+		mdelay(chan.vcc_powerup_delay_ms);
+	}
 	regmap_write(ldb->regmap, ldb->ctrl_reg, ldb->ctrl);
+	if (gpio_is_valid(chan.backlight_gpio)) {
+		mdelay(chan.backlight_powerup_delay_ms);
+		gpio_set_value(chan.backlight_gpio,
+			       !chan.backlight_active_low);
+	}
 	return 0;
 }
 
@@ -586,7 +603,15 @@ static void ldb_disable(struct mxc_dispdrv_handle *mddh,
 				      LDB_CH0_MODE_MASK);
 	}
 
+	if (gpio_is_valid(ldb->chan[chno].backlight_gpio)) {
+		gpio_set_value(ldb->chan[chno].backlight_gpio,
+			       ldb->chan[chno].backlight_active_low);
+	}
 	regmap_write(ldb->regmap, ldb->ctrl_reg, ldb->ctrl);
+	if (gpio_is_valid(ldb->chan[chno].vcc_gpio)) {
+		gpio_set_value(ldb->chan[chno].vcc_gpio,
+			       ldb->chan[chno].vcc_active_low);
+	}
 	return;
 }
 
@@ -704,6 +729,77 @@ static bool is_valid_crtc(struct ldb_data *ldb, enum crtc crtc,
 	return false;
 }
 
+static void lvds_power_gpio(struct device *dev, struct device_node *np,
+			    struct ldb_chan *chan)
+{
+	int ret;
+	enum of_gpio_flags flags;
+
+	chan->vcc_gpio = -1;
+	chan->backlight_gpio = -1;
+
+	chan->vcc_gpio = of_get_named_gpio_flags(np, "vcc-gpio", 0, &flags);
+	if (!gpio_is_valid(chan->vcc_gpio)) {
+		dev_warn(dev, "vcc-gpio not valid");
+		return;
+	}
+	dev_info(dev, "lvds vcc gpio: %d\n", chan->vcc_gpio);
+	chan->vcc_active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	ret = gpio_request(chan->vcc_gpio, "lvds-vcc-gpio");
+	if (ret) {
+		dev_err(dev, "Could not get lvds-vcc-gpio %d", chan->vcc_gpio);
+		return;
+	}
+
+	if (gpio_direction_output(chan->vcc_gpio, chan->vcc_active_low)) {
+		dev_err(dev, "Could not set direction of vcc gpio");
+		goto err;
+	}
+
+	ret = of_property_read_u32(np, "vcc-powerup-delay-ms",
+				   &chan->vcc_powerup_delay_ms);
+	if (ret) {
+		dev_info(dev, "Could not get 'vcc-powerup-delay-ms'");
+	}
+
+	chan->backlight_gpio = of_get_named_gpio_flags(np, "backlight-gpio", 0,
+						       &flags);
+	if (!gpio_is_valid(chan->backlight_gpio)) {
+		dev_warn(dev, "backlight-gpio not valid");
+		goto err;
+	}
+	dev_info(dev, "lvds backlight gpio: %d\n", chan->backlight_gpio);
+	chan->backlight_active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	ret = gpio_request(chan->backlight_gpio, "lvds-backlight-gpio");
+	if (ret) {
+		dev_err(dev, "Could not get backlight gpio %d",
+			chan->backlight_gpio);
+		goto err;
+	}
+
+	if (gpio_direction_output(chan->backlight_gpio,
+				  chan->backlight_active_low)) {
+		dev_err(dev, "Could not set direction of backlight gpio");
+		goto err_bl;
+	}
+
+	ret = of_property_read_u32(np, "backlight-powerup-delay-ms",
+				   &chan->backlight_powerup_delay_ms);
+	if (ret) {
+		dev_info(dev, "Could not get 'backlight-powerup-delay-ms'");
+	}
+
+	return;
+err_bl:
+	gpio_free(chan->backlight_gpio);
+	chan->backlight_gpio = -1;
+err:
+	gpio_free(chan->vcc_gpio);
+	chan->vcc_gpio = -1;
+}
+
 static int ldb_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -804,6 +900,8 @@ static int ldb_probe(struct platform_device *pdev)
 		chan->ldb = ldb;
 		chan->online = true;
 
+		lvds_power_gpio(dev, child, chan);
+
 		is_primary = of_property_read_bool(child, "primary");
 
 		if (ldb->bus_mux_num == 1 || (ldb->primary_chno == -1 &&
-- 
2.1.4


From 62e9e0e69199aa4492cbfca80bd53286f971d2ef Mon Sep 17 00:00:00 2001
From: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date: Thu, 23 Jan 2020 14:58:06 +0100
Subject: [PATCH] Backport imx6ull OCOTP access patch

This commit fix imx6ull OCOTP register access. Ohterwise the SOC freezes
when the OCOTP register is accessed.

Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
---
 arch/arm/boot/dts/imx6ull.dtsi  |  5 +++++
 arch/arm/mach-imx/mach-imx6ul.c | 49 +++++++++++++++++++++++------------------
 drivers/nvmem/imx-ocotp.c       |  1 +
 3 files changed, 34 insertions(+), 21 deletions(-)

diff --git a/arch/arm/boot/dts/imx6ull.dtsi b/arch/arm/boot/dts/imx6ull.dtsi
index 88d3f878d0da..c13a834bef03 100644
--- a/arch/arm/boot/dts/imx6ull.dtsi
+++ b/arch/arm/boot/dts/imx6ull.dtsi
@@ -121,6 +121,8 @@
 				      "pll1_sw", "pll1_sys", "pll1_bypass", "pll1", "pll1_bypass_src", "osc";
 			arm-supply = <&reg_arm>;
 			soc-supply = <&reg_soc>;
+			nvmem-cells = <&cpu_speed_grade>;
+			nvmem-cell-names = "speed_grade";
 		};
 	};
 
@@ -1026,6 +1028,9 @@
 				compatible = "fsl,imx6ull-ocotp", "syscon";
 				reg = <0x021bc000 0x4000>;
 				clocks = <&clks IMX6UL_CLK_OCOTP>;
+				cpu_speed_grade: speed-grade@10 {
+					reg = <0x10 4>;
+				};
 			};
 
 			csu: csu@021c0000 {
diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c
index 99eb8ad811cb..74cada1600d4 100644
--- a/arch/arm/mach-imx/mach-imx6ul.c
+++ b/arch/arm/mach-imx/mach-imx6ul.c
@@ -9,6 +9,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
 #include <linux/micrel_phy.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/phy.h>
@@ -76,24 +77,35 @@ static void __init imx6ul_enet_phy_init(void)
 
 static void __init imx6ul_opp_check_speed_grading(struct device *cpu_dev)
 {
-	struct device_node *np;
-	void __iomem *base;
 	u32 val;
+	int ret = 0;
+
+	if (of_find_property(cpu_dev->of_node, "nvmem-cells", NULL)) {
+		ret = nvmem_cell_read_u32(cpu_dev, "speed_grade", &val);
+		if (ret)
+			return;
+	} else {
+		struct device_node *np;
+		void __iomem *base;
+
+		if (cpu_is_imx6ul())
+			np = of_find_compatible_node(NULL, NULL, "fsl,imx6ul-ocotp");
+		else
+			np = of_find_compatible_node(NULL, NULL, "fsl,imx6ull-ocotp");
+
+		if (!np) {
+			pr_warn("failed to find ocotp node\n");
+			return;
+		}
 
-	if (cpu_is_imx6ul())
-		np = of_find_compatible_node(NULL, NULL, "fsl,imx6ul-ocotp");
-	else
-		np = of_find_compatible_node(NULL, NULL, "fsl,imx6ull-ocotp");
-
-	if (!np) {
-		pr_warn("failed to find ocotp node\n");
-		return;
-	}
-
-	base = of_iomap(np, 0);
-	if (!base) {
-		pr_warn("failed to map ocotp\n");
-		goto put_node;
+		base = of_iomap(np, 0);
+		of_node_put(np);
+		if (!base) {
+			pr_warn("failed to map ocotp\n");
+			return;
+		}
+		val = readl_relaxed(base + OCOTP_CFG3);
+		iounmap(base);
 	}
 
 	/*
@@ -104,7 +116,6 @@ static void __init imx6ul_opp_check_speed_grading(struct device *cpu_dev)
 	 * 2b'11: 900000000Hz(i.MX6ULL);
 	 * We need to set the max speed of ARM according to fuse map.
 	 */
-	val = readl_relaxed(base + OCOTP_CFG3);
 	val >>= OCOTP_CFG3_SPEED_SHIFT;
 	val &= 0x3;
 	if (cpu_is_imx6ul()) {
@@ -125,10 +136,6 @@ static void __init imx6ul_opp_check_speed_grading(struct device *cpu_dev)
 				pr_warn("Failed to disable 900MHz OPP\n");
 		}
 	}
-	iounmap(base);
-
-put_node:
-	of_node_put(np);
 }
 
 static void __init imx6ul_opp_init(void)
diff --git a/drivers/nvmem/imx-ocotp.c b/drivers/nvmem/imx-ocotp.c
index a4ddab73d2c9..1c424960b610 100644
--- a/drivers/nvmem/imx-ocotp.c
+++ b/drivers/nvmem/imx-ocotp.c
@@ -330,6 +330,7 @@ static const struct of_device_id imx_ocotp_dt_ids[] = {
 	{ .compatible = "fsl,imx6sl-ocotp", (void *)64 },
 	{ .compatible = "fsl,imx6sx-ocotp", (void *)128 },
 	{ .compatible = "fsl,imx6ul-ocotp", (void *)128 },
+	{ .compatible = "fsl,imx6ull-ocotp", (void *)128 },
 	{ .compatible = "fsl,imx7d-ocotp", (void *)64 },
 	{ .compatible = "fsl,imx8mq-ocotp", (void *)256 },
 	{ },
-- 
2.16.4


From ba3d550e412f01c468860e3380570aca32f13c36 Mon Sep 17 00:00:00 2001
From: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date: Mon, 4 Nov 2013 15:15:52 +0100
Subject: [PATCH] Add machine hikirk to the kernel.

The kernel's sources are modified accordingly.

Signed-off-by: Angelika Tobisch <tobisch@dresearch-fe.de>
Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
---
 arch/arm/mach-kirkwood/Kconfig        |    6 +
 arch/arm/mach-kirkwood/Makefile       |    1 +
 arch/arm/mach-kirkwood/hikirk-setup.c |  250 +++++++++++++++++++++++++++++++++
 arch/arm/tools/mach-types             |    1 +
 4 files changed, 258 insertions(+)
 create mode 100644 arch/arm/mach-kirkwood/hikirk-setup.c

diff --git a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
index 7509a89..151ce9b 100644
--- a/arch/arm/mach-kirkwood/Kconfig
+++ b/arch/arm/mach-kirkwood/Kconfig
@@ -2,6 +2,12 @@ if ARCH_KIRKWOOD
 
 menu "Marvell Kirkwood Implementations"
 
+config MACH_HIKIRK
+	bool "Marvell HIKIRK Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell HIKIRK Board.
+
 config MACH_D2NET_V2
 	bool "LaCie d2 Network v2 NAS Board"
 	help
diff --git a/arch/arm/mach-kirkwood/Makefile b/arch/arm/mach-kirkwood/Makefile
index e1f3735..74f2f5d 100644
--- a/arch/arm/mach-kirkwood/Makefile
+++ b/arch/arm/mach-kirkwood/Makefile
@@ -1,5 +1,6 @@
 obj-y				+= common.o irq.o pcie.o mpp.o
 
+obj-$(CONFIG_MACH_HIKIRK)		+= hikirk-setup.o
 obj-$(CONFIG_MACH_D2NET_V2)		+= d2net_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_DB88F6281_BP)		+= db88f6281-bp-setup.o
 obj-$(CONFIG_MACH_DOCKSTAR)		+= dockstar-setup.o
diff --git a/arch/arm/mach-kirkwood/hikirk-setup.c b/arch/arm/mach-kirkwood/hikirk-setup.c
new file mode 100644
index 0000000..1c7f229
--- /dev/null
+++ b/arch/arm/mach-kirkwood/hikirk-setup.c
@@ -0,0 +1,250 @@
+/*
+ * arch/arm/mach-kirkwood/hikirk-setup.c
+ *
+ * Hikirk Board Setup
+ * 
+ * based on:
+ * Marvell OpenRD (Base|Client|Ultimate) Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+
+static struct mtd_partition spi_flash_parts[] = {
+        {
+                .name = "boot-header",
+                .size = 65536,
+                .offset = 0,
+        },
+	{
+                .name = "u-boot-0",
+                .size = 917504,
+                .offset = 65536,
+        },
+	{
+                .name = "u-boot-1",
+                .size = 917504,
+                .offset = 983040,
+        },
+	{
+                .name = "u-boot-env",
+                .size = 131072,
+                .offset = 1900544,
+        },
+       {
+                .name = "spare",
+                .size = 65536,
+                .offset = 2031616,
+        },
+	{
+                .name = "kernel-0",
+                .size = 7340032,
+                .offset = 2097152,
+        },
+	{
+                .name = "kernel-1",
+                .size = 7340032,
+                .offset = 9437184,
+        },
+
+};
+
+static const struct flash_platform_data spi_flash = {
+        .type           = "N25Q128A13E",
+        .name           = "spi_flash",
+        .parts          = spi_flash_parts,
+        .nr_parts       = 7,
+};  
+
+static struct spi_board_info __initdata spi_slave_info[] = {
+        {
+                .modalias       = "m25p80",
+                .platform_data  = &spi_flash,
+                .irq            = -1,
+                .max_speed_hz   = 80000000,
+                .bus_num        = 0,
+                .chip_select    = 0,
+        },
+};
+
+void __init spi_register_flash(void)
+{
+        spi_register_board_info(spi_slave_info,
+                                ARRAY_SIZE(spi_slave_info));
+        kirkwood_spi_init();
+}
+
+
+static struct mv643xx_eth_platform_data hikirk_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(2),
+};
+
+static struct mv643xx_eth_platform_data hikirk_ge01_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(3),
+};
+
+static struct mv_sata_platform_data hikirk_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct mvsdio_platform_data hikirk_mvsdio_data = {
+	.gpio_card_detect = 29,	/* MPP29 used as SD card detect */
+};
+
+static unsigned int hikirk_mpp_config[] __initdata = {
+	MPP12_SD_CLK,
+	MPP13_SD_CMD,
+	MPP14_SD_D0,
+	MPP15_SD_D1,
+	MPP16_SD_D2,
+	MPP17_SD_D3,
+	MPP28_GPIO,
+	MPP29_GPIO,
+	MPP34_GPIO,
+	MPP35_GPIO,
+	MPP36_GPIO,
+	MPP37_GPIO,
+	MPP38_GPIO,
+	0
+};
+
+static void __init set_ethaddr(char *str, struct mv643xx_eth_platform_data* eth_data)
+{
+	int i;
+	unsigned int mac[6];
+
+	if(!str) { return; }
+
+	if(6 == sscanf(str, "%x:%x:%x:%x:%x:%x", &mac[0], &mac[1], &mac[2], 
+						&mac[3], &mac[4], &mac[5])) {
+		for(i=0; i<6; ++i) {
+			eth_data->mac_addr[i] = (u8)(mac[i] & 0xFF);
+		}
+	} else {
+		printk(KERN_WARNING "Command line mac invalid: '%s'\n", str);
+	}
+}
+
+static int __init set_eth0addr(char *str)
+{
+	set_ethaddr(str, &hikirk_ge00_data);
+	return 1;
+}
+
+static int __init set_eth1addr(char *str)
+{
+	set_ethaddr(str, &hikirk_ge01_data);
+	return 1;
+}
+
+/* Parse boot_command_line string ethaddr */
+__setup("ethaddr=", set_eth0addr);
+__setup("eth1addr=", set_eth1addr);
+
+static int __init hdd_host_mpp_config(void)
+{
+	printk(KERN_INFO "Enable and set HOST_RUNNING\n");
+	if (gpio_request(36, "HOST_RUNNING")) {
+		printk(KERN_ERR "GPIO request failed for HOST_RUNNING"
+				", gpio: 36\n");
+		return -EIO;
+	}
+	if (gpio_direction_output(36, 1)) {
+		printk(KERN_ERR "GPIO direction output failed for HOST_RUNNING"
+				", gpio: 36\n");
+	} else if (gpio_export(36, 0)) {
+		printk(KERN_ERR "GPIO export failed for HOST_RUNNING"
+				", gpio# 36\n");
+	}
+
+	printk(KERN_INFO "Enable HDD_USABLE as input\n");
+	if (gpio_request(37, "HDD_USABLE")) {
+		printk(KERN_ERR "GPIO request failed for HDD_USABLE"
+				", gpio# 37\n");
+		gpio_free(36);
+		return -EIO;
+	}
+
+	if (gpio_direction_input(37)) {
+		printk(KERN_ERR "GPIO direction input failed for HDD_USABLE"
+				", gpio# 37\n");
+	} else if (gpio_export(37, 0)) {
+		printk(KERN_ERR "GPIO export failed for HDD_USABLE"
+				", gpio# 37\n");
+	}
+
+	return 0;
+}
+
+static void hikirk_power_off(void)
+{
+	printk(KERN_INFO "Reset HOST_RUNNING\n");
+	gpio_set_value(36, 0);
+	while(1);
+}
+
+static void __init hikirk_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(hikirk_mpp_config);
+
+	kirkwood_uart0_init();
+	spi_register_flash();
+
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&hikirk_ge00_data);
+	kirkwood_ge01_init(&hikirk_ge01_data);
+	
+	kirkwood_sata_init(&hikirk_sata_data);
+
+	kirkwood_i2c_init();
+
+	hdd_host_mpp_config();
+
+	pm_power_off = hikirk_power_off;
+
+	kirkwood_sdio_init(&hikirk_mvsdio_data);
+}
+
+static int __init hikirk_pci_init(void)
+{
+	kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(hikirk_pci_init);
+
+
+MACHINE_START(HIKIRK, "Kirkwood based HydraIP device")
+	.atag_offset	= 0x100,
+	.init_machine	= hikirk_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
+
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index a10297d..264dd0e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1007,3 +1007,4 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+hikirk			MACH_HIKIRK		HIKIRK			4745
-- 
1.7.9.5


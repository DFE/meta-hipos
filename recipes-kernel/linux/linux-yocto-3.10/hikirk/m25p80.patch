diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 2f3d2a5..3d53082 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -67,6 +67,8 @@
 #define	SR_BP0			4	/* Block protect 0 */
 #define	SR_BP1			8	/* Block protect 1 */
 #define	SR_BP2			0x10	/* Block protect 2 */
+#define SR_BP_TB		0x20	/* Block protect Top/Bootm */
+#define SR_BP3                  0x40    /* Block protect 3 */
 #define	SR_SRWD			0x80	/* SR write protect */
 
 /* Define max times to check status register before we give up. */
@@ -655,6 +657,160 @@ err:	mutex_unlock(&flash->lock);
 	return res;
 }
 
+static int n25q128a13_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+        struct m25p *flash = mtd_to_m25p(mtd);
+        uint32_t offset = ofs;
+        uint8_t status_old, status_new;
+        int res = 0;
+
+        mutex_lock(&flash->lock);
+        /* Wait until finished previous command */
+        if (wait_till_ready(flash)) {
+                res = 1;
+                goto err;
+        }
+
+        status_old = read_sr(flash);
+
+        if (( offset+len > flash->mtd.size/2 ) && ( offset > flash->mtd.size/2 ))
+        {
+
+                if (offset >= flash->mtd.size-(flash->mtd.size/256))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP1)))|SR_BP0;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/128))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP0)))|SR_BP1;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/64))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2)))|SR_BP1|SR_BP0;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/32))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP1|SR_BP0)))|SR_BP2;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/16))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP1)))|SR_BP2|SR_BP0;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/8))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP0)))|SR_BP2|SR_BP1;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/4))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3)))|SR_BP2|SR_BP1|SR_BP0;
+                        }
+                else if (offset >= flash->mtd.size-(flash->mtd.size/2))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP2|SR_BP1|SR_BP0)))|SR_BP3;
+                        }
+		else
+			{
+				status_new = (status_old & (~(SR_BP_TB)))|SR_BP3|SR_BP2|SR_BP1|SR_BP0;
+			}
+
+        } else 
+        {
+                status_new = (status_old & (~(SR_BP_TB)))|SR_BP3|SR_BP2|SR_BP1|SR_BP0;
+        } 
+
+        /* Only modify protection if it will not unlock other areas */
+        if ((status_new&(SR_BP3|SR_BP2|SR_BP1|SR_BP0)) >
+                                        (status_old&(SR_BP3|SR_BP2|SR_BP1|SR_BP0))) {
+                write_enable(flash);
+                if (write_sr(flash, status_new) < 0) {
+                        res = 1;
+                        goto err;
+                }
+        }
+
+err:    mutex_unlock(&flash->lock);
+        return res;
+}
+
+static int n25q128a13_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+        struct m25p *flash = mtd_to_m25p(mtd);
+        uint32_t offset = ofs;
+        uint8_t status_old, status_new;
+        int res = 0;
+
+        mutex_lock(&flash->lock);
+        /* Wait until finished previous command */
+        if (wait_till_ready(flash)) {
+                res = 1;
+                goto err;
+        }
+
+        status_old = read_sr(flash);
+
+	if (( offset+len > flash->mtd.size/2 ) && ( offset >= flash->mtd.size/2 ))
+	{
+		if ( (status_old&SR_BP_TB) != 0 )
+			{
+				status_new = status_old;
+			}
+		else if (offset+len > flash->mtd.size-(flash->mtd.size/256))
+                        {
+                                status_new = status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP1|SR_BP0));
+                        }
+		else if (offset+len > flash->mtd.size-(flash->mtd.size/128))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP1)))|SR_BP0;
+                        }
+                else if (offset+len > flash->mtd.size-(flash->mtd.size/64))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP0)))|SR_BP1;
+                        }
+                else if (offset+len > flash->mtd.size-(flash->mtd.size/32))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP2)))|SR_BP1|SR_BP0;
+                        }
+                else if (offset+len > flash->mtd.size-(flash->mtd.size/16))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP1|SR_BP0)))|SR_BP2;
+                        }
+                else if (offset+len > flash->mtd.size-(flash->mtd.size/8))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP1)|SR_BP2))|SR_BP0;
+	                }
+        	else if (offset+len > flash->mtd.size-(flash->mtd.size/4))
+	                {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3|SR_BP0)))|SR_BP2|SR_BP1;
+	                }
+		else if (offset+len > flash->mtd.size-(flash->mtd.size/2))
+                        {
+                                status_new = (status_old & (~(SR_BP_TB|SR_BP3)))|SR_BP2|SR_BP1|SR_BP0;
+                        }
+		else
+                        {
+                                status_new = status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP1|SR_BP0));
+                        }
+
+
+	} else 
+	{
+		status_new = status_old & (~(SR_BP_TB|SR_BP3|SR_BP2|SR_BP1|SR_BP0));
+	} 
+
+        /* Only modify protection if it will not lock other areas */
+        if ((status_new&(SR_BP3|SR_BP2|SR_BP1|SR_BP0)) <
+                                        (status_old&(SR_BP3|SR_BP2|SR_BP1|SR_BP0))) {
+                write_enable(flash);
+                if (write_sr(flash, status_new) < 0) {
+                        res = 1;
+                        goto err;
+                }
+        }
+
+err:    mutex_unlock(&flash->lock);
+        return res;
+}
+
 /****************************************************************************/
 
 /*
@@ -953,10 +1109,11 @@ static int m25p_probe(struct spi_device *spi)
 			 * marked read-only, and we don't want to lose that
 			 * information, even if it's not 100% accurate.
 			 */
-			dev_warn(&spi->dev, "found %s, expected %s\n",
-				 jid->name, id->name);
+			dev_warn(&spi->dev, "found %s, expected %s (0x%x)\n",
+				 jid->name, id->name,info->jedec_id);
 			id = jid;
 			info = (void *)jid->driver_data;
+			dev_warn(&spi->dev, "jedec_id: 0x%x\n",info->jedec_id);
 		}
 	}
 
@@ -999,7 +1156,12 @@ static int m25p_probe(struct spi_device *spi)
 	flash->mtd._read = m25p80_read;
 
 	/* flash protection support for STmicro chips */
-	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ST) {
+	if ( strcmp(id->name,"n25q128a13") == 0 ) {
+		dev_warn(&spi->dev, "use n25q128a13_lock\n");
+		flash->mtd._lock = n25q128a13_lock;
+		flash->mtd._unlock = n25q128a13_unlock;
+	} else if ( JEDEC_MFR(info->jedec_id) == CFI_MFR_ST ) {
+		dev_warn(&spi->dev, "use m25p80_lock\n");
 		flash->mtd._lock = m25p80_lock;
 		flash->mtd._unlock = m25p80_unlock;
 	}

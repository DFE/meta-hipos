From 72966d1b653edbd9340da684dd3441397ec85e0a Mon Sep 17 00:00:00 2001
From: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
Date: Mon, 4 Nov 2013 15:30:30 +0100
Subject: [PATCH] usb: add PLX Tech 3380 driver

Add USB PLX Tech 3380 chip driver.

Signed-off-by: Mario Schuknecht <mario.schuknecht@dresearch-fe.de>
---
 drivers/usb/gadget/Kconfig      |   13 +
 drivers/usb/gadget/Makefile     |    1 +
 drivers/usb/gadget/usb3380.c    | 3780 +++++++++++++++++++++++++++++++++++++++
 drivers/usb/gadget/usb3380.h    |  319 ++++
 drivers/usb/gadget/usb3380_hw.h |  643 +++++++
 5 files changed, 4756 insertions(+)
 create mode 100644 drivers/usb/gadget/usb3380.c
 create mode 100644 drivers/usb/gadget/usb3380.h
 create mode 100644 drivers/usb/gadget/usb3380_hw.h

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index f41aa0d..9c4ff06 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -421,6 +421,19 @@ config USB_NET2280
 	   dynamically linked module called "net2280" and force all
 	   gadget drivers to also be dynamically linked.
 
+config USB_USB3380
+	tristate "PLX USB338x"
+	depends on PCI
+	select USB_GADGET_DUALSPEED
+	select USB_GADGET_SUPERSPEED
+	help
+	   PLX USB 338x is a PCI based USB peripheral controller which
+	   supports full/high/super speed USB 3.0 data transfers.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "usb3380" and force all
+	   gadget drivers to also be dynamically linked.
+
 config USB_GOKU
 	tristate "Toshiba TC86C001 'Goku-S'"
 	depends on PCI
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 6afd166..f7d2c65 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -10,6 +10,7 @@ libcomposite-y			+= composite.o functions.o configfs.o
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2272)	+= net2272.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
+obj-$(CONFIG_USB_USB3380)	+= usb3380.o
 obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc.o
 obj-$(CONFIG_USB_PXA25X)	+= pxa25x_udc.o
 obj-$(CONFIG_USB_PXA27X)	+= pxa27x_udc.o
diff --git a/drivers/usb/gadget/usb3380.c b/drivers/usb/gadget/usb3380.c
new file mode 100644
index 0000000..fca22de
--- /dev/null
+++ b/drivers/usb/gadget/usb3380.c
@@ -0,0 +1,3780 @@
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/prefetch.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+/*****************************************************************************/
+static int use_dma = 1;
+module_param (use_dma, uint, S_IRUGO);
+
+/* enable_suspend -- When enabled, the driver will respond to
+ * USB suspend requests by powering down the USB3380.  Otherwise,
+ * USB suspend requests will be ignored.  This is acceptible for
+ * self-powered devices
+ */
+static int enable_suspend = 0;
+module_param (enable_suspend, uint, S_IRUGO);
+
+static int log_entries = 2000;
+module_param (log_entries, uint, S_IRUGO);
+
+static int dma_outstanding_r = 6;
+module_param (dma_outstanding_r, uint, S_IRUGO);
+
+static int dma_outstanding_w = 6;
+module_param (dma_outstanding_w, uint, S_IRUGO);
+
+/*****************************************************************************/
+#define	DRIVER_DESC		"PLX USB338x Peripheral Controller"
+#define	DRIVER_VERSION		"Release-1.3.1 2013 Jan 14"
+
+static const char driver_name [] = "usb3380";
+static const char driver_desc [] = DRIVER_DESC;
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static int enhanced = 0;
+
+static const char ep0name [] = "ep0";
+static const char *ep_name[][9] = {
+	{ ep0name, "ep1", "ep2", "ep3", "ep4", },
+	{ ep0name, "ep1in", "ep2out", "ep3in", "ep4out", "ep1out", "ep2in", "ep3out", "ep4in" },
+};
+
+static int ep_count;
+
+#include "usb3380.h"
+
+/* FSM value for Defect 7374 (U1U2 Test) is managed in chip's SCRATCH register:
+ * Reg/Bit/Val 		Reg /// Bit /// Val ////
+ */
+#define	DEFECT7374_FSM_FIELD	28	//31:28
+
+typedef enum _DEFECT7374_FSM
+{   
+	/* A finite state machine for Defect 7374 workaround is managed 
+	 * in the chip's SCRATCH register:
+	 *  - The nature of the Defect 7374 is that it must be executed only
+	 *    once, after the chip powers up.
+	 *  - Using a chip register allows the FSM state to persist even when 
+	 *    the driver unloads and reloads.
+	 *  - Using a chip register allows the FSM state to automatically
+	 *    reset when the system recovers from hibernation.
+	 */
+
+	/* The FSM's reset state is the chip register's power-on value:
+	 *  - The FSM state is managed in SCRATCH[31:28] 
+	 *  - The chip's SCRATCH register power-on value is 0xFEEDFACE
+	 */
+	DEFECT7374_FSM_RESET = (0xFEEDFACE & (0xf << 28)),
+
+	// Undefined state applies to errors, debug and development.
+	DEFECT7374_FSM_UNDEFINED = (0 << DEFECT7374_FSM_FIELD),
+
+	/* Waiting for Control Read:
+	 *  - A transition to this state indicates a fresh USB connection,
+	 *    before the first Setup Packet. The connection speed is not
+	 *    known. Firmware is waiting for the first Control Read.
+	 *  - Starting state: This state can be thought of as the FSM's typical
+	 *    starting state.
+	 *  - Tip: Upon the first SS Control Read the FSM never
+	 *    returns to this state.
+	 */
+	DEFECT7374_FSM_WAITING_FOR_CONTROL_READ = (1 << DEFECT7374_FSM_FIELD),
+
+	/* Non-SS Control Read:
+	 *  - A transition to this state indicates detection of the first HS
+	 *    or FS Control Read.
+	 *  - Tip: Upon the first SS Control Read the FSM never
+	 *    returns to this state.
+	 */
+	DEFECT7374_FSM_NON_SS_CONTROL_READ = (2 << DEFECT7374_FSM_FIELD),
+
+	/* SS Control Read:
+	 *  - A transition to this state indicates detection of the 
+	 *    first SS Control Read.
+	 *  - This state indicates workaround completion. Workarounds no longer
+	 *    need to be applied (as long as the chip remains powered up).
+	 *  - Tip: Once in this state the FSM state does not change (until
+	 *    the chip's power is lost and restored).
+	 *  - This can be thought of as the final state of the FSM;
+	 *    the FSM 'locks-up' in this state until the chip loses power.
+	 */
+	DEFECT7374_FSM_SS_CONTROL_READ = (3 << DEFECT7374_FSM_FIELD),
+} DEFECT7374_FSM, * PDEFECT7374_FSM;                                                                                                                                                       
+
+static u32 log_level = LOG_INFO;
+
+static struct usb3380	*usb3380_controller;
+
+#define MAX_PACKET_PER_SERVICE_INTERVAL 11
+static void set_ep_maxpacket(struct usb3380_ep *ep, u32 max)
+{
+	struct usb3380 *dev = ep->dev;
+	u32 speed_bias = 0; /* High-Speed */
+	u32 index;
+
+	switch (dev->gadget.speed) {
+		case USB_SPEED_FULL:
+			speed_bias = 1;
+			break;
+		case USB_SPEED_SUPER:
+			speed_bias = 2;
+			max |= (0x2 << MAX_PACKET_PER_SERVICE_INTERVAL);
+			break;
+		default:
+			break;
+	}
+
+	if (enhanced) {
+		/* ep2,4,5,7 are OUT endpoints, and ep1,3,6,8 are IN endpoints. */
+		if (ep->num < 5) {
+			index = (ep->num % 2 == 0) ?
+			/* OUT */ ((ep->num-1) * 0x10) + 0x20 + speed_bias :
+			/* IN */ ((ep->num-1) * 0x10) + 0x60 + speed_bias;
+		} else {
+			index = (ep->num % 2 != 0) ?
+			/* OUT */ ((ep->num-5) * 0x10) + 0x20 + speed_bias :
+			/* IN */ ((ep->num-5) * 0x10) + 0x60 + speed_bias;
+		}
+	} else {
+		/* Legacy Mode
+		 * The values in GPEP OUT CSRs are used for both the IN and OUT
+		 * direction of a GPEP.
+		 */
+		index = (ep->num + 1) * 0x10 + speed_bias;
+	}
+
+	set_idx_reg(dev->regs, index, max);
+}
+
+static inline u32 PCIIRQBit(u32 ep_num)
+{
+	if (enhanced){
+		if (ep_num > 4)
+			return ((ep_num % 2 != 0) ? (ep_num-4) : ((ep_num-4) + 16));
+		else
+			return ((ep_num % 2 == 0) ? (ep_num) : (ep_num + 16));
+	} else {
+		return ep_num;
+	}
+}
+
+static __maybe_unused char *
+EpTypeString (const struct usb_endpoint_descriptor *desc) 
+{
+	static char *xfer_string[] = { "control", "iso", "bulk", "intr" };
+
+	if (!desc)
+		return xfer_string[USB_ENDPOINT_XFER_CONTROL];
+
+	switch (usb_endpoint_type(desc)) {
+		case USB_ENDPOINT_XFER_INT:
+			return xfer_string[USB_ENDPOINT_XFER_INT];
+		case USB_ENDPOINT_XFER_BULK:
+			return xfer_string[USB_ENDPOINT_XFER_BULK];
+		case USB_ENDPOINT_XFER_ISOC:
+			return xfer_string[USB_ENDPOINT_XFER_ISOC];
+	};
+	return xfer_string[USB_ENDPOINT_XFER_CONTROL];
+}
+
+/*****************************************************************************/
+
+void __dbglog(log_level_t level, char *text, u32 arg1, u32 arg2, u32 arg3)
+{
+	log_entry_t *queue = usb3380_controller->logger.queue;
+	unsigned int entries = usb3380_controller->logger.entries;
+	unsigned int *wrptr = &usb3380_controller->logger.wrptr;
+	unsigned int *rdptr = &usb3380_controller->logger.rdptr;
+	const unsigned int w_index = *wrptr;
+
+	if (likely(level > log_level))
+		return;
+	
+	memcpy(&queue[w_index].text, text, sizeof(queue[w_index].text));
+	queue[w_index].arg1 = arg1;
+	queue[w_index].arg2 = arg2;
+	queue[w_index].arg3 = arg3;
+
+	*wrptr = (w_index + 1) % entries;
+	if (*wrptr == *rdptr)	/* overflow */
+		*rdptr = (*rdptr + 1) % entries;
+}
+
+int usb3380_init_logger(struct usb3380 *dev, unsigned int entries)
+{
+	unsigned int bufsiz = PAGE_ALIGN(entries * sizeof(log_entry_t));
+	void *mem = vmalloc(bufsiz);
+
+	if (mem == NULL) {
+		ERRMSG(dev, "Failed to allocate %d bytes for logger\n", bufsiz);
+		return -ENOMEM;
+	}
+
+	dev->logger.rdptr = dev->logger.wrptr = 0;
+	dev->logger.entries = bufsiz / sizeof(log_entry_t);
+	dev->logger.queue = (log_entry_t *)mem;
+
+	return 0;
+}
+
+void usb3380_cleanup_logger(struct usb3380 *dev)
+{
+	if (dev->logger.queue)
+		vfree(dev->logger.queue);
+}
+
+/*****************************************************************************/
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
+
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+
+#define USB3380_SEQ_RO_ATTR(_name)	\
+struct file_operations _name##_dbg_fops = {	\
+	.owner   = THIS_MODULE,	\
+	.open    = _name##_dbg_open,	\
+	.llseek  = seq_lseek,	\
+	.read    = seq_read,	\
+	.release = single_release,	\
+}
+
+#define USB3380_UDC_SEQ_RO_ATTR(_name)	\
+static int _name##_dbg_open(struct inode *inode, struct file *file)	\
+{	\
+	return single_open(file, _name##_dbg_show, inode->i_private);	\
+}	\
+\
+USB3380_SEQ_RO_ATTR(_name);
+
+#define USB3380_RW_ATTR(_name)	\
+static struct file_operations _name##_dbg_fops = {	\
+	.owner   = THIS_MODULE,	\
+	.open    = _name##_dbg_open,	\
+	.llseek  = default_llseek,	\
+	.read    = _name##_dbg_read,	\
+	.write   = _name##_dbg_write,	\
+}
+
+#define USB3380_UDC_RW_ATTR(_name)	\
+static int _name##_dbg_open(struct inode *inode, struct file *file)	\
+{	\
+	file->private_data = inode->i_private;	\
+	return 0;	\
+}	\
+\
+USB3380_RW_ATTR(_name);
+
+static int regs_dbg_show(struct seq_file *s, void *p)
+{
+	struct usb3380 *dev = s->private;
+	unsigned long flags;
+	int pos = 0, i;
+	u32 t1, t2;
+
+	if (!dev->driver)
+		return -ENODEV;
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	/* USB Controller Device-Specific Registers */
+	pos += seq_printf(s, "%s version " DRIVER_VERSION
+			", chiprev %04x, dma %s\n\n"
+			"devinit %03x gadget '%s'\n"
+			"cpu irqenb0 %06x irqenb1 %08x "
+			"pci irqenb0 %06x irqenb1 %08x "
+			"irqstat0 %04x irqstat1 %08x "
+			"gpioctrl %08x gpiostat %01x\n",
+			driver_name, dev->chiprev,
+			use_dma ? "enabled" : "disabled",
+			readl (&dev->regs->devinit),
+			dev->driver
+				? dev->driver->driver.name
+				: "(none)",
+			readl (&dev->regs->cpuirqenb0),
+			readl (&dev->regs->cpuirqenb1),
+			readl (&dev->regs->pciirqenb0),
+			readl (&dev->regs->pciirqenb1),
+			readl (&dev->regs->irqstat0),
+			readl (&dev->regs->irqstat1),
+			readl (&dev->regs->gpioctrl),
+			readl (&dev->regs->gpiostat));
+
+	/* USB Control Registers */
+	t1 = readl (&dev->usb->usbctl);
+	t2 = readl (&dev->usb->usbstat);
+
+	pos += seq_printf(s, "stdrsp %08x usbctl %08x usbctl2 %08x usbstat %08x "
+			"xcvrdiag %08x addr 0x%02x ",
+			readl (&dev->usb->stdrsp), t1,
+			readl (&dev->usb->usbctl2), t2,
+			readl (&dev->usb->xcvrdiag),
+			readl (&dev->usb->ouraddr));
+
+	if (t1 & (1 << VBUS_PIN)) {	/* Connected to the USB */
+		if (t2 & (1 << SUPER_SPEED_MODE))
+			pos += seq_printf(s, "(super speed)\n");
+		else if (t2 & (1 << HIGH_SPEED_MODE))
+			pos += seq_printf(s, "(high speed)\n");
+		else if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+			pos += seq_printf(s, "(powered)\n");
+		else
+			pos += seq_printf(s, "(full speed)\n");
+	} else
+		pos += seq_printf(s, "(not attached)\n");
+
+	/* PCI Master Control Registers */
+
+	/* DMA Control Registers */
+
+	/* Configurable EP Control Registers */
+	for (i = 0; i <= ep_count; i++) {
+		struct usb3380_ep *ep = &dev->ep[i];
+
+		if (i && !ep->desc)
+			continue;
+
+		t1 = readl (&ep->cfg->ep_cfg);
+		t2 = readl (&ep->regs->ep_rsp) & 0xff;
+
+		pos += seq_printf(s,
+				"\n%s\tcfg %08x rsp (%02x) %s%s%s%s%s%s%s%s irqenb %02x\n",
+				ep->ep.name, t1, t2,
+				(t2 & (1 << CLEAR_NAK_PACKETS))
+					? "NAK " : "",
+				(t2 & (1 << CLEAR_EP_HIDE_STATUS_STAGE))
+					? "hide " : "",
+				(t2 & (1 << CLEAR_EP_FORCE_CRC_ERROR))
+					? "CRC " : "",
+				(t2 & (1 << CLEAR_INTERRUPT_MODE))
+					? "interrupt " : "",
+				(t2 & (1<<CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE))
+					? "status " : "",
+				(t2 & (1 << CLEAR_NAK_OUT_PACKETS_MODE))
+					? "NAKmode " : "",
+				(t2 & (1 << CLEAR_ENDPOINT_TOGGLE))
+					? "DATA1 " : "DATA0 ",
+				(t2 & (1 << CLEAR_ENDPOINT_HALT))
+					? "HALT " : "",
+				readl (&ep->regs->ep_irqenb));
+
+		pos += seq_printf(s, "\tstat %08x avail %04x ",
+				readl (&ep->regs->ep_stat),
+				readl (&ep->regs->ep_avail));
+
+		if (enhanced) {
+			pos += seq_printf(s, "(%s-%s)%s\n",
+					ep_name[enhanced][ep->num], EpTypeString(ep->desc),
+					ep->stopped ? "*": "");
+		} else {
+			pos += seq_printf(s, "(%s%s-%s)%s\n",
+					ep_name[enhanced][ep->num], (ep->is_in) ? "in": "out",
+					EpTypeString(ep->desc),
+					ep->stopped ? "*": "");
+		}
+
+		if (!ep->dma)
+			continue;
+
+		pos += seq_printf(s, "  dma\tctl %08x stat %08x count %08x "
+				"countp %08x\n"
+				"\taddr %08x addrp %08x desc %08x descp %08x\n",
+				readl (&ep->dma->dmactl),
+				readl (&ep->dma->dmastat),
+				readl (&ep->dma->dmacount),
+				readl (&ep->dmap->dmacountp),
+				readl (&ep->dma->dmaaddr),
+				readl (&ep->dmap->dmaaddrp),
+				readl (&ep->dma->dmadesc),
+				readl (&ep->dmap->dmadescp));
+	}
+
+	spin_unlock_irqrestore (&dev->lock, flags);
+	return 0;
+}
+USB3380_UDC_SEQ_RO_ATTR(regs);
+
+static int queues_dbg_show(struct seq_file *s, void *p)
+{
+	struct usb3380 *dev = s->private;
+	unsigned long flags;
+	int i, pos = 0;
+
+	if (!dev->driver)
+		return -ENODEV;
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	for (i = 0; i < ep_count; i++) {
+		struct usb3380_ep *ep = &dev->ep[i];
+		struct usb3380_request *req;
+
+		if (i != 0) {
+			const struct usb_endpoint_descriptor *d = ep->desc;
+
+			if (!d)
+				continue;
+
+			if (enhanced) {
+				pos += seq_printf(s, "(%s-%s) ",
+						ep->ep.name, EpTypeString(ep->desc));
+			} else {
+				pos += seq_printf(s, "(%s%s-%s) ",
+						ep->ep.name, (ep->is_in) ? "in": "out",
+						EpTypeString(ep->desc));
+			}
+			pos += seq_printf(s, "max %04x %s fifo %x\n",
+					le16_to_cpu(d->wMaxPacketSize) & 0x1fff,
+					ep->dma ? "dma" : "pio", ep->fifo_size);
+		} else {
+			pos += seq_printf(s, "ep0 max %04x pio %s fifo %x\n",
+					ep->ep.maxpacket,
+					(ep->is_in) ? "in": "out",
+					ep->fifo_size);
+		}
+
+		if (list_empty (&ep->queue)) {
+			pos += seq_printf(s, "\t(nothing queued)\n");
+			continue;
+		}
+		list_for_each_entry (req, &ep->queue, queue) {
+			if (ep->dma && req->td_dma == readl (&ep->dma->dmadesc))
+				pos += seq_printf(s, "\treq %p len %x/%x "
+					"buf %p (dmacount %08x)\n",
+					&req->req, req->req.actual,
+					req->req.length, req->req.buf,
+					readl (&ep->dma->dmacount));
+			else
+				pos += seq_printf(s, "\treq %p len %x/%x buf %p\n",
+					&req->req, req->req.actual,
+					req->req.length, req->req.buf);
+
+			if (ep->dma) {
+				struct usb3380_dma *td = req->td;
+
+				pos += seq_printf(s, "\t    td %08x "
+					" count %08x buf %08x desc %08x\n",
+					(u32) req->td_dma,
+					le32_to_cpu (td->dmacount),
+					le32_to_cpu (td->dmaaddr),
+					le32_to_cpu (td->dmadesc));
+			}
+		}
+	}
+
+	spin_unlock_irqrestore (&dev->lock, flags);
+	return 0;
+}
+USB3380_UDC_SEQ_RO_ATTR(queues);
+
+static int func_dbg_show(struct seq_file *s, void *p)
+{
+	struct usb3380 *dev = s->private;
+
+	if (!(dev->driver && dev->driver->function))
+		return -ENODEV;
+
+	seq_printf(s, "%s\n", dev->driver->function);
+	return 0;
+}
+USB3380_UDC_SEQ_RO_ATTR(func);
+
+static int logs_dbg_show(struct seq_file *s, void *p)
+{
+	struct usb3380 *dev = s->private;
+	unsigned long flags;
+	unsigned int wrptr, rdptr, line;
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	for (line = 0, wrptr = dev->logger.wrptr, rdptr = dev->logger.rdptr;
+			(wrptr != rdptr);
+			rdptr = (rdptr + 1) % dev->logger.entries, line++) {
+		seq_printf(s, "  -%3u: "LOGFMT"\n",
+				line,
+				(char*)&dev->logger.queue[rdptr].text,
+				dev->logger.queue[rdptr].arg1,
+				dev->logger.queue[rdptr].arg2,
+				dev->logger.queue[rdptr].arg3);
+	}
+
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	return 0;
+}
+USB3380_UDC_SEQ_RO_ATTR(logs);
+
+static ssize_t loglvl_dbg_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "%u\n", log_level);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t loglvl_dbg_write(struct file *file, const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	unsigned long mask;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (strict_strtoul(buf, 0, &mask))
+		return -EINVAL;
+
+	log_level = mask;
+	return count;
+}
+USB3380_UDC_RW_ATTR(loglvl);
+
+static struct dbgfs_regmap {
+	char *qualifier;
+	char *name;
+	u32 offset;
+} dbgfs_regs[] = {
+	/* USB Configuration Registers */
+	/* USB Controller Device-Specific Registers */
+	{0, "devinit", 0x0}, {0, "pciirqenb0", 0x10}, {0, "pciirqenb1", 0x14},
+	{0, "cpuirqenb0", 0x18}, {0, "cpuirqenb1", 0x1c}, {0, "irqstat0", 0x28},
+	{0, "irqstat1", 0x2c}, {0, "idxaddr", 0x30}, {0, "idxdata", 0x34},
+	{0, "gpioctrl", 0x50}, {0, "gpiostat", 0x54}, 
+	/* USB Interface Control Register */
+	{0, "stdrsp", 0x80}, {0, "usbctl", 0x8c}, {0, "usbstat", 0x90}, 
+	{0, "xcvrdiag", 0x94}, {0, "usbctl2", 0xc8},
+	/* DMA Registers */
+	{"dma", "dmactl", 0x180}, {"dma", "dmastat", 0x184},
+	{"dma", "dmacount", 0x190}, {"dma", "dmaaddr", 0x194},
+	{"dma", "dmadesc", 0x198}, {"dma", "dmacountp", 0x680},
+	{"dma", "dmaaddrp", 0x684}, {"dma", "dmadescp", 0x688},
+	/* EP0 and GPEPx Registers */
+	{"ep", "ep_cfg", 0x300}, {"ep", "ep_rsp", 0x304},
+	{"ep", "ep_irqenb", 0x308}, {"ep", "ep_stat", 0x30c},
+	{"ep", "ep_avail", 0x310}, {"ep", "ep_val", 0x31c}
+};
+
+static ssize_t regval_dbg_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	char buf[] = "\"<reg> = <val>\" or \"<epN>.<reg> = <val>\" or "
+		"\"<dmaN>.<reg> = <val>\"\n";
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+static char *strtrim(char *string)
+{
+	int last = strlen(string) - 1;
+	char c;
+
+	/* trim tail */
+	for (c = string[last]; c == ' ' || c == '\t'; last--, c = string[last])
+		string[last] = '\0';
+	/* trim head */
+	for (c = *string; c == ' ' || c == '\t'; string++, c = *string);
+
+	return string;
+}
+
+#define QTYPE_EP	1
+#define QTYPE_DMA	2
+static ssize_t regval_dbg_write(struct file *file, const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	unsigned long val32, bias = 0;
+	char buf[80];
+	ssize_t len;
+	char *line = &buf[0];
+	char *name = NULL, *value = NULL, *qualifier = NULL;
+	int loc, q_type = 0;
+	struct dbgfs_regmap *entry;
+
+	struct usb3380 *dev = file->private_data;
+	u32 __iomem *addr;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+
+	if ((qualifier = strsep(&line, "=")) != NULL)
+		qualifier = strtrim(qualifier);
+
+	if ((name = strchr(qualifier, '.')) != NULL) {
+		*name++ = '\0';
+		if (!strncmp(qualifier, "ep", 2)) {
+			if (strict_strtoul(&qualifier[2], 0, &bias))
+				return -EINVAL;
+			qualifier[2] = '\0';
+			q_type = QTYPE_EP;
+		} else if (!strncmp(qualifier, "dma", 3)) {
+			if (strict_strtoul(&qualifier[3], 0, &bias))
+				return -EINVAL;
+			qualifier[3] = '\0';
+			q_type = QTYPE_DMA;
+		} else
+			return -EINVAL;
+	} else
+		name = qualifier;
+
+	if ((value = strsep(&line, "=")) != NULL)
+		value = strtrim(value);
+
+	for (loc = 0; loc < ARRAY_SIZE(dbgfs_regs); loc++) {
+		if (dbgfs_regs[loc].qualifier && (name != qualifier) &&
+				strcmp(dbgfs_regs[loc].qualifier, qualifier))
+			continue;
+		if (!strcmp(dbgfs_regs[loc].name, name))
+			break;
+	}
+
+	if (loc >= ARRAY_SIZE(dbgfs_regs))
+		return -EINVAL;
+
+	if (strict_strtoul(value, 16, &val32))
+		return -EINVAL;
+
+	entry = &dbgfs_regs[loc];
+	switch (q_type) {
+		case QTYPE_DMA:
+			if (bias > NR_DMA_CHANNEL) return -EINVAL;
+			if (entry->name[strlen(entry->name) - 1] == 'p')
+				bias *= 0x10;
+			else
+				bias *= 0x20;
+			break;
+		case QTYPE_EP:
+			if (bias > ep_count) return -EINVAL;
+			if (enhanced) {
+			   if (strcmp(entry->name, "ep_cfg") &&
+					   strcmp(entry->name, "ep_val")) {
+				if (bias > 4) {
+					bias = ((bias !=0) && (bias % 2 != 0)) ? ((bias - 4) * 0x20) : (((bias - 4) * 0x20) + 0xC0);
+				} else {
+					bias = ((bias !=0) && (bias % 2 != 0)) ? ((bias * 0x20) + 0xC0) : (bias * 0x20);
+				}
+			} else
+				bias = (bias % 4 == 0)? 0x80 : (bias % 4)*0x20;
+			} else 
+				bias *= 0x20;
+			break;
+		default:
+			bias = 0;
+	}
+
+	addr = (void *)dev->regs + entry->offset + bias;
+
+	writel (val32, addr);
+
+	return count;
+}
+USB3380_UDC_RW_ATTR(regval);
+
+static struct dbgfs_config {
+	char *name;
+	struct file_operations *fops;
+	mode_t mode;
+} dbgfs_vars[] = {
+	{"regs", &regs_dbg_fops, 0400},
+	{"queues", &queues_dbg_fops, 0400},
+	{"functions", &func_dbg_fops, 0400},
+	{"logs", &logs_dbg_fops, 0400},
+	{"log_level", &loglvl_dbg_fops, 0600},
+	{"reg_val", &regval_dbg_fops, 0600},
+};
+
+static void usb3380_init_debugfs(struct usb3380 *dev)
+{
+	struct dentry *root, *attr;
+	int i;
+
+    root = debugfs_create_dir(dev->gadget.name, NULL);
+	if (IS_ERR(root) || !root)
+		goto err_root;
+
+	for (i=0; i<ARRAY_SIZE(dbgfs_vars); i++) {
+		attr = debugfs_create_file(dbgfs_vars[i].name,
+				dbgfs_vars[i].mode,
+				root, dev, dbgfs_vars[i].fops);
+		if (!attr)
+			ERRMSG(dev, "Failed to create %s in debugfs\n", dbgfs_vars[i].name);
+	}
+
+	dev->debugfs_root = root;
+	return;
+
+err_root:
+	ERRMSG(dev, "debugfs is not available\n");
+}
+
+static void usb3380_cleanup_debugfs(struct usb3380 *dev)
+{
+	if (dev->debugfs_root) {
+		debugfs_remove_recursive(dev->debugfs_root);
+		dev->debugfs_root = NULL;
+	}
+}
+
+#else
+
+static void usb3380_init_debugfs(struct usb3380 *dev) {}
+static void usb3380_cleanup_debugfs(struct usb3380 *dev) {}
+
+#endif
+
+/*****************************************************************************/
+
+static int handshake (u32 __iomem *ptr, u32 mask, u32 done, int usec)
+{
+	u32	result;
+
+	do {
+		result = readl (ptr);
+		if (result == ~(u32)0)		/* "device unplugged" */
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay (1);
+		usec--;
+	} while (usec > 0);
+	VLOG("Timo", 0, 0, 0);
+	return -ETIMEDOUT;
+}
+
+ /*
+  * used where the host wrote "too much" data to us.
+  */
+static __maybe_unused void
+out_flush (struct usb3380_ep *ep)
+{
+	u32	__iomem *statp;
+	u32	tmp;
+
+	statp = &ep->regs->ep_stat;
+	writel ((1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+			(1 << DATA_PACKET_RECEIVED_INTERRUPT)
+			, statp);
+	writel ((1 << FIFO_FLUSH), statp);
+	mb ();
+	tmp = readl (statp);
+	DBG("Flsh", ep->num, tmp, 0);
+	if (tmp & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)
+			/* high speed did bulk NYET; fifo isn't filling */
+			&& ep->dev->gadget.speed == USB_SPEED_FULL) {
+		unsigned	usec;
+
+		usec = 50;		/* 64 byte bulk/interrupt */
+		handshake (statp, (1 << USB_OUT_NAK_SENT),
+				(1 << USB_OUT_NAK_SENT), usec);
+		/* NAK done; now CLEAR_NAK_OUT_PACKETS is safe */
+	}
+}
+
+/* unload packet(s) from the fifo we use for usb OUT transfers.
+ * returns true iff the request completed, because of short packet
+ * or the request buffer having filled with full packets.
+ */
+static int
+read_fifo (struct usb3380_ep *ep, struct usb3380_request *req)
+{
+	struct usb3380_ep_regs __iomem *regs = ep->regs;
+	u8 *buf = req->req.buf + req->req.actual;
+	u32 tmp, count, ep_stat;
+	int is_short;
+
+	/* never overflow the rx buffer. the fifo reads packets until
+	 * it sees a short one; we might not be ready for them all.
+	 */
+	prefetchw (buf);
+	ep_stat = readl (&regs->ep_stat);
+	count = readl (&regs->ep_avail);
+
+	do {
+		DBG("Aval", count, ep_stat, ep->ep.maxpacket);
+
+		/* A ZLP OUT packet may be in the endpoint */
+		if (count == 0)
+			break;
+
+		writel ((1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+				(1 << DATA_IN_TOKEN_INTERRUPT)
+				, &regs->ep_stat);
+
+		tmp = req->req.length - req->req.actual;
+		if (count > tmp)
+			count = tmp;
+
+		req->req.actual += count;
+
+		/* read data from the fifo */
+		while (count >= 4) {
+			tmp = readl (&regs->ep_data);
+			cpu_to_le32s (&tmp);
+			put_unaligned (tmp, (u32 *)buf);
+			buf += 4;
+			count -= 4;
+		}
+		/* the remaining bytes (less than 4 bytes) */
+		if (count) {
+			tmp = readl (&regs->ep_data);
+			/* LE conversion is implicit here: */
+			do {
+				*buf++ = (u8) tmp;
+				tmp >>= 8;
+			} while (--count);
+		}
+
+		ep_stat = readl (&regs->ep_stat);
+		count = readl (&regs->ep_avail);
+
+	} while (count && req->req.actual != req->req.length);
+
+	is_short = ep_stat & ((1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+			(1 << ZLP_INTERRUPT));
+
+	if (ep_stat & (1 << ZLP_INTERRUPT))
+		writel ((1 << ZLP_INTERRUPT), &regs->ep_stat);
+
+	if (ep_stat & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)) {
+		writel ((1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+				(1 << SHORT_OUT_PACKET_DONE_INTERRUPT)
+				, &regs->ep_stat);
+	}
+
+	DBG("RdFl", ep_stat, req->req.actual, req->req.length);
+
+	/* return true if the transfer is complete */
+	return is_short || ((req->req.actual == req->req.length)
+				&& !req->req.zero);
+}
+
+/* load a packet into the fifo we use for usb IN transfers.
+ * works for all endpoints.
+ * one packet is written to the fifo at a time
+ */
+static void
+write_fifo (struct usb3380_ep *ep, struct usb_request *req)
+{
+	struct usb3380_ep_regs __iomem *regs = ep->regs;
+	u8 *buf;
+	u32 tmp;
+	unsigned count, total;
+
+	if (req) {
+		buf = req->buf + req->actual;
+		prefetch (buf);
+		total = req->length - req->actual;
+	} else {
+		total = 0;
+		buf = NULL;
+	}
+
+	if (readl (&ep->regs->ep_avail) == 0) {
+		VLOG("Full", readl (&ep->regs->ep_stat), req->actual, req->length);
+		return;
+	}
+
+	/* write just one packet at a time */
+	count = ep->ep.maxpacket;
+	if (count > total)	/* min() cannot be used on a bitfield */
+		count = total;
+
+	DBG("WrF0", count, req->actual, req->length);
+
+	while (count >= 4) {
+		/* NOTE be careful if you try to align these. fifo lines
+		 * should normally be full (4 bytes) and successive partial
+		 * lines are ok only in certain cases.
+		 */
+		tmp = get_unaligned ((u32 *)buf);
+		cpu_to_le32s (&tmp);
+		writel (tmp, &regs->ep_data);
+		buf += 4;
+		count -= 4;
+	}
+
+	/* last fifo entry is "short" unless we wrote a full packet.
+	 * also explicitly validate last word in (periodic) transfers
+	 * when maxpacket is not a multiple of 4 bytes.
+	 */
+	if (count || total < ep->ep.maxpacket) {
+		tmp = count ? get_unaligned ((u32 *)buf) : count;
+		cpu_to_le32s (&tmp);
+		set_fifo_bytecount (ep, count & 0x03);
+		writel (tmp, &regs->ep_data);
+	}
+}
+
+/*****************************************************************************/
+#define valid_bit	(cpu_to_le32 (1 << VALID_BIT))
+#define dma_done_ie	(cpu_to_le32 (1 << DMA_DONE_INTERRUPT_ENABLE))
+
+static void
+done (struct usb3380_ep *ep, struct usb3380_request *req, int status)
+{
+	struct usb3380 *dev;
+	unsigned stopped = ep->stopped;
+
+	VLOG("Done", ep->num, req->req.actual, req->req.length);
+
+	list_del_init (&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	dev = ep->dev;
+	if (req->mapped) {
+		pci_unmap_single (dev->pdev, req->req.dma, req->req.length,
+			ep->is_in ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	spin_unlock (&dev->lock);
+	req->req.complete (&ep->ep, &req->req);
+	spin_lock (&dev->lock);
+	/* Mass Storage might issue a halt */
+	if (!ep->is_halt)
+		ep->stopped = stopped;
+}
+
+static inline void
+dma_done (struct usb3380_ep *ep,
+		struct usb3380_request *req,
+		u32 dmacount,
+		int status)
+{
+	VLOG("DmaD", ep->num, dmacount, (u32)req->td_dma);
+	req->req.actual = req->req.length - (DMA_TRANSFER_MAX_LENGTH & dmacount);
+	if (likely(req->req.actual))
+		done (ep, req, status);
+	else {
+		/* When interrupted by ZLP, the DMA engine will be aborted, causing
+		 * the valid bit of the current dmacount being turned off.
+		 */
+		req->td->dmacount |= valid_bit;
+	}
+}
+
+static void scan_dma_completions (struct usb3380_ep *ep)
+{
+	VLOG("DScn", ep->num, ep->td_dma, 0);
+	/* only look at descriptors that were "naturally" retired,
+	 * so fifo and list head state won't matter
+	 */
+	while (!list_empty (&ep->queue)) {
+		struct usb3380_request *req;
+		u32 stat, avail, dmacount;
+
+		req = list_entry (ep->queue.next, struct usb3380_request, queue);
+		if (!req->valid)
+			break;
+
+		rmb ();
+		dmacount = le32_to_cpup (&req->td->dmacount);
+		VLOG("CkCt", ep->num, dmacount, (u32)req->td_dma);
+		if ((dmacount & (1 << VALID_BIT)) != 0)	//DMA transfer doesn't complete.
+			break;
+
+		if (!ep->is_in && (req->req.length % ep->ep.maxpacket) != 0) {
+			stat = readl (&ep->regs->ep_stat);
+			avail = readl (&ep->regs->ep_avail);
+			/* AVOID TROUBLE HERE by not issuing short reads from
+			 * your gadget driver. Not all cases trigger the warning.
+			 */
+			/* Your gadget driver requests 600 + 200, but the host sends out
+			 * 400 + 400 */
+			if (req->req.length != 31) //request 31 bytes CBW.
+				INFO("Lost", stat, avail, dmacount);
+		}
+
+		dma_done (ep, req, dmacount, 0);
+	}
+}
+
+static inline void spin_stop_dma (struct usb3380_dma_regs __iomem *dma)
+{
+// Just needs to check dmactl enable bit. 
+	handshake (&dma->dmactl, (1 << DMA_ENABLE), 0, 50);
+}
+
+static inline void stop_dma (struct usb3380_ep *ep)
+{
+	writel (readl (&ep->dma->dmactl) & ~(1 << DMA_ENABLE), &ep->dma->dmactl);
+	spin_stop_dma (ep->dma);
+	ep->dma_started = false;
+}
+
+static inline void resume_dma (struct usb3380_ep *ep)
+{
+	writel (readl (&ep->dma->dmactl) | (1 << DMA_ENABLE), &ep->dma->dmactl);
+	ep->dma_started = true;
+}
+
+static inline void abort_dma (struct usb3380_ep *ep)
+{
+	VLOG("DAbt", ep->num, ep->td_dma, 0);
+	writel ((1 << DMA_ABORT), &ep->dma->dmastat);
+	spin_stop_dma (ep->dma);
+	ep->dma_started = false;
+}
+
+/*
+ * 10.3.1: The DMA Scatter/Gather Controller can be configured to pause when
+ * a Cleared Valid bit is detected. In this case, the firmware must restart
+ * the DMA Scatter/Gather Controller after setting up and validating additional
+ * Descriptors.
+ * We use polling so we don't have to setup registers every time.
+ */
+#define DMACTL_SG_STANDARD	\
+	((1 << DMA_DESCRIPTOR_DONE_INTERRUPT_ENABLE) |	\
+	 ((POLL_1_USEC) << DESCRIPTOR_POLLING_RATE) |	\
+	 (1 << DMA_VALID_BIT_POLLING_ENABLE) |	\
+	 (1 << DMA_VALID_BIT_ENABLE) |	\
+	 (1 << DMA_DESCRIPTOR_MODE) |	\
+	 (1 << DMA_CLEAR_COUNT_ENABLE) |	\
+	 (1 << DMA_ENABLE))
+
+static void start_queue (struct usb3380_ep *ep, u32 dmactl, u32 td_dma)
+{
+	struct usb3380_dma_regs	__iomem *dma = ep->dma;
+	u32 tmp = (1 << VALID_BIT) | (ep->is_in << DMA_DIRECTION);
+
+#ifndef USE_3380_FPGA
+	/* FIXME Enabling DMA_REQUEST_OUTSTANDING for USB-IN is highly
+	 * platform dependent. If running Loophost with errors, try to
+	 * enable this for USB-OUT only
+	 */
+	if (ep->is_in)
+		dmactl |=  (dma_outstanding_r << DMA_REQUEST_OUTSTANDING);
+	else
+		dmactl |=  (dma_outstanding_w << DMA_REQUEST_OUTSTANDING);
+#endif
+
+	//writel (0, &dma->dmaaddr);
+	writel (tmp, &dma->dmacount);
+	writel (readl (&dma->dmastat), &dma->dmastat);
+
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+	writel (td_dma|(1<<DMA_DESC_ONCHIP), &dma->dmadesc);
+#else
+	writel (td_dma, &dma->dmadesc);
+#endif
+	writel (dmactl, &dma->dmactl);
+	wmb();
+	writel ((1 << DMA_START), &dma->dmastat);
+
+	VLOG("SDqu", ep->num, dmactl, td_dma);
+
+	ep->dma_started = true;
+
+	if (!ep->is_in){
+		u32 tmp_stat = readl (&ep->regs->ep_stat);
+		/* Got short packet in bulk-out ep fifo, 
+ 		 * don't clear NAK_PACKETS bit here to prevent 
+ 		 * host sending the succeeding packet to fifo 
+ 		 * before DMA transferring the short packet to buffer.
+ 		 * Thus fsg driver get an over 31 bytes CBW.
+ 		 */  
+		if (tmp_stat & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) && (tmp_stat & (1 << NAK_PACKETS))) {
+			INFO("SDq1", ep->num, tmp_stat, 0);
+			return;
+		}
+		stop_out_naking (ep);
+	}
+}
+
+static void
+fill_dma_desc (struct usb3380_ep *ep, struct usb3380_request *req, int valid)
+{
+	struct usb3380_dma *td = req->td;
+	u32 dmacount = req->req.length;
+
+	/* don't let DMA continue after a short OUT packet,
+	 * so overruns can't affect the next transfer.
+	 * in case of overruns on max-size packets, we can't
+	 * stop the fifo from filling but we can flush it.
+	 */
+	if (ep->is_in)
+		dmacount |= (1 << DMA_DIRECTION);
+	else if (dmacount % ep->ep.maxpacket != 0)
+		dmacount |= (1 << LAST_DESCRIPTOR);
+
+	req->valid = valid;
+	if (valid)
+		dmacount |= (1 << VALID_BIT);
+	if (likely(!req->req.no_interrupt))
+		dmacount |= (1 << DMA_DONE_INTERRUPT_ENABLE);
+
+	/* td->dmadesc = previously set by caller */
+	td->dmaaddr = cpu_to_le32 (req->req.dma);
+	/* Be careful here. DMA may be polling the valid bit until it's set on to
+	 * proceed.
+	 */
+	wmb ();
+	td->dmacount = cpu_to_le32 (dmacount);
+}
+
+static void queue_dma(struct usb3380_ep *ep, struct usb3380_request *req)
+{
+	struct usb3380_dma *end;
+	dma_addr_t addr;
+
+	u32 tmp = DMACTL_SG_STANDARD;
+	int valid = 1;
+	u32 tmp_stat;
+
+	/* If DMA is still working, it's probably waiting for the valid bit of the
+	 * last descriptor to be turn on. In the case, we switch the descriptor
+	 * with the dummy and turn on the valid bit to start DMA
+	 * PS: We always switch the descriptor with the dummy even the DMA is not
+	 * working because it's no harm.
+	 */ 
+
+	VLOG("QDma", ep->num, req->req.length, ep->td_dma);
+	/* swap new dummy for old, link; fill and maybe activate */
+	end = ep->dummy;
+	ep->dummy = req->td;
+	req->td = end;
+
+	addr = ep->td_dma;
+	ep->td_dma = req->td_dma;
+	req->td_dma = addr;
+	/* pointing to the current dummy */
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+	end->dmadesc = cpu_to_le32 (ep->td_dma |(1<<DMA_DESC_ONCHIP));
+#else
+	end->dmadesc = cpu_to_le32 (ep->td_dma);
+#endif
+	/* Fill out the descriptor and turn on the valid bit to start DMA
+	 * transfers.
+	 */
+	/* kickstart this i/o queue? */
+	if (list_empty (&ep->queue) && !ep->stopped) {
+		writel (0, &ep->dma->dmactl);
+		/* force packet boundaries between dma requests, but prevent the
+		 * controller from automagically writing a last "short" packet
+		 * (zero length) unless the driver explicitly said to do that.
+		 */
+		if (ep->is_in) {
+			if (req->req.zero || (req->req.length % ep->ep.maxpacket)) {
+				tmp |= (1 << DMA_FIFO_VALIDATE);
+				ep->in_fifo_validate = 1;
+			} else
+				ep->in_fifo_validate = 0;
+		}
+
+#if 1
+		tmp_stat = readl (&ep->regs->ep_stat);
+
+		// previous OUT packet might have been short
+//		if (!ep->is_in && (tmp_stat & (1 << NAK_PACKETS) != 0)) {
+		if (!ep->is_in){
+			if (tmp_stat & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)){
+//				writel ((1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT), &ep->regs->ep_stat);
+
+				u32 tmp_avail = readl (&ep->regs->ep_avail);
+
+				DBG("QDm0", tmp_stat, tmp_avail, 0);
+
+				if ((tmp_stat & (1 << NAK_PACKETS)) == 0)
+					printk(KERN_WARNING "queue_dma got short before starting but not NAKing ep_stat=%x, ep_avail=%x\n", tmp_stat, tmp_avail);
+
+				if (tmp_avail) {
+					writel (readl (&ep->dma->dmastat), &ep->dma->dmastat);
+
+					// transfer all/some fifo data
+					writel (req->req.dma, &ep->dma->dmaaddr);
+					tmp_avail = min (tmp_avail, req->req.length);
+
+					// dma irq, faking scatterlist status
+					req->td->dmacount = cpu_to_le32 (req->req.length - tmp_avail);
+					writel ((1 << DMA_DONE_INTERRUPT_ENABLE) | 1 << LAST_DESCRIPTOR | tmp_avail, &ep->dma->dmacount);
+					req->td->dmadesc = 0;
+					req->valid = 1;
+					writel ((1 << DMA_ENABLE), &ep->dma->dmactl);
+					writel ((1 << DMA_START), &ep->dma->dmastat);
+					return;
+				}
+			}
+		}
+#endif
+
+		fill_dma_desc (ep, req, 1);
+		start_queue (ep, tmp, req->td_dma);
+	} else {
+		int validate = req->req.zero || (req->req.length % ep->ep.maxpacket);
+		/* The DMA is working and probably has reached the last descriptor,
+		 * waiting for the valid bit to be turned on
+		 */
+		if (ep->is_in && validate != ep->in_fifo_validate)
+			valid = 0;
+
+		fill_dma_desc (ep, req, valid);
+	}
+}
+
+static void restart_dma (struct usb3380_ep *ep)
+{
+	struct usb3380_request	*req;
+	u32 dmactl = DMACTL_SG_STANDARD;
+	u32 dmastat;
+
+	if (ep->stopped)
+		return;
+
+	req = list_entry (ep->queue.next, struct usb3380_request, queue);
+
+	VLOG("SDma", ep->num, req->req.actual, req->req.length);
+
+	/* the 3380 will be processing the queue unless queue hiccups after
+	 * the previous transfer:
+	 *  IN:   wanted automagic zlp, head doesn't (or vice versa)
+	 *        DMA_FIFO_VALIDATE doesn't init from dma descriptors.
+	 *  OUT:  was "usb-short", we must restart.
+	 */
+	if (ep->is_in && !req->valid) {
+		struct usb3380_request	*entry, *prev = NULL;
+		int	reqmode, done = 0;
+
+		ep->in_fifo_validate = likely (req->req.zero
+			|| (req->req.length % ep->ep.maxpacket) != 0);
+		if (ep->in_fifo_validate)
+			dmactl |= (1 << DMA_FIFO_VALIDATE);
+
+		VLOG("Hicp", ep->in_fifo_validate, req->req.zero, ep->td_dma);
+
+		list_for_each_entry (entry, &ep->queue, queue) {
+			__le32		dmacount;
+
+			if (entry == req)
+				continue;
+			dmacount = entry->td->dmacount;
+			if (!done) {
+				reqmode = likely (entry->req.zero
+					|| (entry->req.length
+						% ep->ep.maxpacket) != 0);
+				if (reqmode == ep->in_fifo_validate) {
+					entry->valid = 1;
+					dmacount |= valid_bit;
+					entry->td->dmacount = dmacount;
+					prev = entry;
+					continue;
+				} else {
+					/* force a hiccup */
+					prev->td->dmacount |= dma_done_ie;
+					done = 1;
+				}
+			}
+
+			/* walk the rest of the queue so unlinks behave */
+			entry->valid = 0;
+			dmacount &= ~valid_bit;
+			entry->td->dmacount = dmacount;
+			prev = entry;
+		}
+		/* Set the valid bit for the first one */
+		req->valid = 1;
+		if (dma_in_progress (ep)) {
+			writel (dmactl, &ep->dma->dmactl);
+			wmb();
+			/* The DMA Engine is waiting for valid_bit turned on to resume
+			 * DMA transfer */
+			req->td->dmacount |= valid_bit;
+			return;
+		}
+		req->td->dmacount |= valid_bit;
+	}
+
+	/* If a DMAC unexpectedly hangs during an operation,
+	   it can be cleared by writing ‘h5A to the DMASTAT CSR
+	*/
+
+	dmastat=readl (&ep->dma->dmastat);
+	VLOG("EpRt", dmastat, 0, 0);
+
+	if (dmastat == 0x5002) {
+		printk(KERN_WARNING "The dmastat return = %x!!\n", dmastat);
+		writel( 0x5a, &ep->dma->dmastat);
+	}
+
+	writel (0, &ep->dma->dmactl);
+	start_queue (ep, dmactl, req->td_dma);
+}
+
+/*****************************************************************************/
+
+/* dequeue ALL requests */
+static void nuke (struct usb3380_ep *ep)
+{
+	struct usb3380_request	*req;
+
+	VLOG("Nuke", ep->num, 0, 0);
+	/* called with spinlock held */
+	ep->stopped = 1;
+	if (ep->dma)
+		abort_dma (ep);
+	while (!list_empty (&ep->queue)) {
+		req = list_entry (ep->queue.next, struct usb3380_request, queue);
+		done (ep, req, -ESHUTDOWN);
+	}
+}
+
+static void
+usb3380_fifo_flush (struct usb_ep *_ep);
+
+/* dequeue JUST ONE request */
+static int usb3380_dequeue (struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct usb3380_ep *ep;
+	struct usb3380_request *req;
+	unsigned long flags;
+	u32 dmactl, tmp_dmacount;
+	int stopped;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0) || !_req)
+		return -EINVAL;
+
+	if (!ep->dev->driver)
+		return -ESHUTDOWN;
+
+	spin_lock_irqsave (&ep->dev->lock, flags);
+	stopped = ep->stopped;
+
+	VLOG("DeQu", ep->num, 0, 0);
+	/* quiesce dma while we patch the queue */
+	dmactl = 0;
+	ep->stopped = 1;
+	if (ep->dma) {
+		dmactl = readl (&ep->dma->dmactl);
+		/* Don't stop dma when DMAC is working. Use abort dma instead. */
+		abort_dma(ep);
+		scan_dma_completions (ep);
+	}
+
+	/* make sure it's still queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore (&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	/* queue head may be partially complete. */
+	if (ep->queue.next == &req->queue) {
+		if (ep->dma) {
+			INFO("Unlk", 0, 0, 0);
+			_req->status = -ECONNRESET;
+			abort_dma (ep);
+
+			/* Clear DMA Transfer Length bits in dmacount register. */
+			tmp_dmacount=readl(&ep->dma->dmacount);
+			writel((tmp_dmacount & ~DMA_TRANSFER_MAX_LENGTH), &ep->dma->dmacount);
+			//usb3380_fifo_flush(ep); //Don't need to flush!?
+
+			if (likely (ep->queue.next == &req->queue)) {
+				// NOTE: misreports single-transfer mode
+				req->td->dmacount = 0;	/* invalidate */
+				dma_done (ep, req,
+					readl (&ep->dma->dmacount),
+					-ECONNRESET);
+			}
+		} else {
+			INFO("Unk1", 0, 0, 0);
+			done (ep, req, -ECONNRESET);
+		}
+		req = NULL;
+
+	/* patch up hardware chaining data */
+	} else if (ep->dma) {
+		VLOG("Ptch", (u32)req->queue.prev, (u32)ep->queue.next, ep->td_dma);
+		if (req->queue.prev == ep->queue.next) {
+			writel (le32_to_cpu (req->td->dmadesc), &ep->dma->dmadesc);
+			if (req->td->dmacount & dma_done_ie)
+				writel (readl (&ep->dma->dmacount) | le32_to_cpu(dma_done_ie),
+					&ep->dma->dmacount);
+		} else {
+			struct usb3380_request *prev;
+			prev = list_entry (req->queue.prev, struct usb3380_request, queue);
+			prev->td->dmadesc = req->td->dmadesc;
+			if (req->td->dmacount & dma_done_ie)
+				prev->td->dmacount |= dma_done_ie;
+		}
+	}
+
+	if (req)
+		done (ep, req, -ECONNRESET);
+
+	ep->stopped = stopped;
+	if (ep->dma) {
+		/* turn off dma on inactive queues */
+		if (list_empty (&ep->queue)) {
+			abort_dma (ep);
+		} else if (!ep->stopped) {
+			/* resume current request, or start new one */
+			if (req)
+				writel (dmactl, &ep->dma->dmactl);
+			else
+				restart_dma (ep);
+		}
+	}
+
+	spin_unlock_irqrestore (&ep->dev->lock, flags);
+	return 0;
+}
+
+static int
+usb3380_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct usb3380_request *req;
+	struct usb3380_ep *ep;
+	struct usb3380 *dev;
+	unsigned long flags;
+
+	/* we always require a cpu-view buffer, so that we can
+	 * always use pio (as fallback or whatever).
+	 */
+	req = container_of (_req, struct usb3380_request, req);
+	if (!_req || !_req->complete || !_req->buf
+			|| !list_empty (&req->queue))
+		return -EINVAL;
+	if (_req->length > DMA_TRANSFER_MAX_LENGTH)
+		return -EDOM;
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return -EINVAL;
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	/* FIXME implement PIO fallback for ZLPs with DMA */
+	if (ep->dma && _req->length == 0)
+		return -EOPNOTSUPP;
+
+	/* set up dma mapping in case the caller didn't */
+	if (ep->dma && _req->dma == DMA_ADDR_INVALID) {
+		_req->dma = pci_map_single (dev->pdev, _req->buf, _req->length,
+			ep->is_in ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);
+		req->mapped = 1;
+	}
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	DBG("Enq0", ep->num, (u32)req->td_dma, _req->length);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	if (ep->dma) {
+		queue_dma(ep, req);
+	} else
+	/* kickstart this i/o queue? */
+	if (list_empty (&ep->queue) && !ep->stopped) {
+		/* maybe there's no control data, just status ack */
+		if (ep->num == 0 && _req->length == 0) {
+			allow_status (ep);
+			done (ep, req, 0);
+			VLOG("Ack0", 0, 0, 0);
+			goto done;
+		}
+
+		/* PIO ... stuff the fifo, or unblock it.  */
+		if (ep->is_in) {
+			write_fifo (ep, _req);
+		}
+		else if (list_empty (&ep->queue)) {
+			u32	s;
+
+			/* OUT FIFO might have packet(s) buffered */
+			s = readl (&ep->regs->ep_stat);
+			if ((s & (1 << FIFO_EMPTY)) == 0) {
+				/* note:  _req->short_not_ok is
+				 * ignored here since PIO _always_
+				 * stops queue advance here, and
+				 * _req->status doesn't change for
+				 * short reads (only _req->actual)
+				 */
+				if (read_fifo (ep, req)) {
+					done (ep, req, 0);
+					if (ep->num == 0) {
+						allow_status (ep);
+					}
+					/* don't queue it */
+					req = NULL;
+				} else
+					s = readl (&ep->regs->ep_stat);
+			}
+			/* don't NAK, let the fifo fill */
+			if (req && (s & (1 << NAK_PACKETS)))
+				stop_out_naking(ep);
+		}
+	}
+
+	ep->responded = 1;
+	if (req)
+		list_add_tail (&req->queue, &ep->queue);
+done:
+	spin_unlock_irqrestore (&dev->lock, flags);
+	return 0;
+}
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+static void *bar_pool_alloc(struct usb3380 *dev, dma_addr_t *handle)
+{
+	unsigned long flags;
+	struct usb3380_dma *td;
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	td = dev->pool_desc;
+	*handle = dev->pool_desc_dma;
+	/* We know 64K is big enough, and it won't overrun. Too bad, too lazy */
+	dev->pool_desc += sizeof(struct usb3380_dma);
+	dev->pool_desc_dma += sizeof(struct usb3380_dma);
+
+	spin_unlock_irqrestore (&dev->lock, flags);
+	return td;
+}
+#endif
+
+static struct usb_request *
+usb3380_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct usb3380_ep *ep;
+	struct usb3380_request *req;
+	//unsigned long flags;
+
+	if (!_ep)
+		return NULL;
+	ep = container_of (_ep, struct usb3380_ep, ep);
+
+	req = kzalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD (&req->queue);
+
+	/* this dma descriptor may be swapped with the previous dummy */
+	if (ep->dma) {
+		struct usb3380_dma *td;
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+		td = bar_pool_alloc(ep->dev, &req->td_dma);
+#else
+		td = pci_pool_alloc (ep->dev->requests, gfp_flags,
+				&req->td_dma);
+		if (!td) {
+			kfree (req);
+			return NULL;
+		}
+#endif
+		td->dmacount = 0;	/* not VALID */
+		td->dmaaddr = cpu_to_le32 (DMA_ADDR_INVALID);
+		td->dmadesc = td->dmaaddr;
+		req->td = td;
+	}
+	return &req->req;
+}
+
+static void
+usb3380_free_request (struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct usb3380_ep *ep;
+	struct usb3380_request *req;
+	//unsigned long flags;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || !_req)
+		return;
+
+	req = container_of (_req, struct usb3380_request, req);
+	WARN_ON (!list_empty (&req->queue));
+#ifndef INTERNAL_DESCRIPTOR
+	if (req->td)
+		pci_pool_free (ep->dev->requests, req->td, req->td_dma);
+#endif
+	kfree (req);
+}
+
+static int
+usb3380_fifo_status (struct usb_ep *_ep)
+{
+	struct usb3380_ep	*ep;
+	u32			avail;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return -ENODEV;
+	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	avail = readl (&ep->regs->ep_avail);
+	if (avail > ep->fifo_size)
+		return -EOVERFLOW;
+	if (ep->is_in)
+		avail = ep->fifo_size - avail;
+
+	return avail;
+}
+
+static void
+usb3380_fifo_flush (struct usb_ep *_ep)
+{
+	struct usb3380_ep	*ep;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return;
+	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return;
+
+	writel ((1 << FIFO_FLUSH), &ep->regs->ep_stat);
+	(void) readl (&ep->regs->ep_rsp);
+}
+
+static void ep_reset(struct usb3380_regs __iomem *, struct usb3380_ep *);
+static int usb3380_disable (struct usb_ep *_ep)
+{
+	struct usb3380_ep *ep;
+	unsigned long flags;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || !ep->desc || _ep->name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave (&ep->dev->lock, flags);
+	DBG("Disb", ep->num, 0, 0);
+	nuke(ep);
+	ep_reset (ep->dev->regs, ep);
+
+	/* synch memory views with the device */
+	(void) readl (&ep->cfg->ep_cfg);
+
+	if (use_dma && !ep->dma && ep->num >= 1 && ep->num <= NR_DMA_CHANNEL) {
+		ep->dma = (struct usb3380_dma_regs __iomem *)
+			&ep->dev->dma[ep->num - 1];
+		ep->dmap = (struct usb3380_dmap_regs __iomem *)
+			&ep->dev->dmap[ep->num - 1];
+	}
+
+	spin_unlock_irqrestore (&ep->dev->lock, flags);
+	return 0;
+}
+
+static int
+usb3380_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct usb3380 *dev;
+	struct usb3380_ep *ep;
+	u32 max, tmp;
+	unsigned long flags;
+	int rc = 0;
+
+	ep = container_of (_ep, struct usb3380_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+			|| desc->bDescriptorType != USB_DT_ENDPOINT)
+		return -EINVAL;
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	if (!enhanced && (ep->num != usb_endpoint_num(desc)))
+		return -EINVAL;
+	/* Dedicated endpoints start at 0x0c */
+	if ((desc->bEndpointAddress & 0x0f) >= 0x0c)
+		return -EDOM;
+
+	/* In Legacy Adapter mode, the 4 endpoints could be configured as either
+	 * IN or OUT endpoint. But in Enhanced mode, we have to check if it's
+	 * compliant with the EP definition
+	 */
+	ep->is_in = usb_endpoint_dir_in(desc) ? 1 : 0;
+
+	// Hard code even(ep 6,8)/odd(ep 1,2)number of endpoints to be in.
+	if (enhanced && ep->is_in && ((ep->num > 4) ? (ep->num % 2 != 0):(ep->num % 2 == 0)))
+		return -EINVAL;
+
+	max = le16_to_cpu(desc->wMaxPacketSize) & 0x7ff;
+	tmp = usb_endpoint_type(desc);
+	switch (tmp) {
+		case USB_ENDPOINT_XFER_INT:
+			if (dev->gadget.speed == USB_SPEED_FULL && max != 0x40)
+				return -ERANGE;
+			/* FIXME: DMA doesn't help a lot on Intr Endpoints. However, when
+			 * the chip is working on enhanced mode, simply disabling the DMA
+			 * channel might not be a good solution. In that case, extra
+			 * effort like the current implementation in epautoconf.c would
+			 * be required to help class drivers choose a suitable endpoint
+			 */
+			if (!enhanced)
+				ep->dma = NULL;
+			break;
+		case USB_ENDPOINT_XFER_BULK:
+			if ((dev->gadget.speed == USB_SPEED_HIGH && max != 0x200) ||
+					(dev->gadget.speed == USB_SPEED_FULL && max > 0x40))
+				return -ERANGE;
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			ep->is_iso = 1;
+			break;
+		default:
+			break;
+	}
+
+	/* Enable this endpoint */
+	/* In Legacy mode, only OUT endpoints are used */
+	if (ep->is_in && enhanced) {
+		tmp <<= IN_ENDPOINT_TYPE;
+		tmp |= (1 << IN_ENDPOINT_ENABLE);
+		tmp |= (1 << ENDPOINT_DIRECTION); /* Not applicable to Legacy */
+	} else {
+		tmp <<= OUT_ENDPOINT_TYPE;
+		tmp |= (1 << OUT_ENDPOINT_ENABLE);
+		tmp |= (ep->is_in << ENDPOINT_DIRECTION);
+	}
+	tmp |= usb_endpoint_num(desc);
+	tmp |= (ep->ep.maxburst << MAX_BURST_SIZE);
+
+	spin_lock_irqsave (&dev->lock, flags);
+	/* GPEPx In/Out share the same ep_cfg. Overwriting this register
+	 * is prohibited */
+	writel (tmp | readl(&ep->cfg->ep_cfg), &ep->cfg->ep_cfg);
+
+	writel ((1 << SET_NAK_OUT_PACKETS_MODE) |
+			(1 << SET_NAK_PACKETS)
+			, &ep->regs->ep_rsp);
+
+	/* Clear endpoint halt, a chip defect workaround:
+	   - SS SeqNum not cleared via Endpoint Halt (Clear) bit.
+	   - Reference: Defect 7341
+	   - Can be applied to clearing HS data toggle and SS sequence number too.
+	   - On SS connections, SeqNum is required to be reset to zero on Clear 
+	   - Endpoint Halt or Clear Endpoint Toggle.
+	*/
+
+	ep_stall (ep, false);
+
+	_ep->maxpacket = max;
+	/* set speed-dependent max packet; may kick in high bandwidth */
+	set_ep_maxpacket(ep, max);
+
+	ep->desc = desc;
+	ep->stopped = 0;
+	ep->wedged = 0;
+	ep->out_overflow = 0;
+
+	/* Compute the fifo size for this endpoint */
+	tmp = readl (&ep->ffregs->ep_fifo_size_base) >> (ep->is_in ?
+		IN_FIFO_SIZE : OUT_FIFO_SIZE);
+	switch (tmp & 0x7) {
+		case FIFO_SIZE_64:
+			ep->fifo_size = 0x40;
+			break;
+		case FIFO_SIZE_128:
+			ep->fifo_size = 0x80;
+			break;
+		case FIFO_SIZE_256:
+			ep->fifo_size = 0x100;
+			break;
+		case FIFO_SIZE_512:
+			ep->fifo_size = 0x200;
+			break;
+		case FIFO_SIZE_1024:
+			ep->fifo_size = 0x400;
+			break;
+		case FIFO_SIZE_2048:
+			ep->fifo_size = 0x800;
+			break;
+		case FIFO_SIZE_4096:
+			ep->fifo_size = 0x1000;
+			break;
+		default:
+			ERROR("FCfg", ep->num, tmp, 0);
+			rc = -EINVAL;
+			goto out;
+	}
+
+	DBG("FSiz", ep->num, ep->fifo_size, ep->is_in);
+
+	/* set type, direction, address; reset fifo counters */
+	writel ((1 << NAK_PACKETS) |
+			(1 << SHORT_PACKET_TRANSFERRED_STATUS) |
+			(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
+			(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
+			(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+			(1 << DATA_IN_TOKEN_INTERRUPT)
+			, &ep->regs->ep_stat);
+	wmb ();
+
+	if (!ep->dma) {
+		/* Enable the corresponding PIO interrupts */
+		tmp = (1 << PCIIRQBit(ep->num)) | readl(&dev->regs->pciirqenb0);
+		writel(tmp, &dev->regs->pciirqenb0);
+
+		tmp = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |
+			  (1 << SHORT_PACKET_RECEIVED_INTERRUPT_ENABLE) |
+			  (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE);
+		writel(tmp, &ep->regs->ep_irqenb);
+	} else {
+		/* Enable the corresponding DMA channel interrupts */
+		tmp = (1 << (8 + ep->num)) | readl(&dev->regs->pciirqenb1);
+		writel (tmp, &dev->regs->pciirqenb1);
+
+		/* for short OUT transfers, dma completions can't
+		 * advance the queue; do it pio-style, by hand.
+		 */
+		if (!ep->is_in) {
+			writel((1 << SHORT_PACKET_RECEIVED_INTERRUPT_ENABLE), &ep->regs->ep_irqenb);//Enable this interrupt for invalid CBW testing
+			writel((1 << SHORT_PACKET_OUT_DONE_INTERRUPT_ENABLE),
+					&ep->regs->ep_irqenb);
+
+			tmp = (1 << PCIIRQBit(ep->num)) | readl(&dev->regs->pciirqenb0);
+			writel(tmp, &dev->regs->pciirqenb0);
+		}
+	}
+
+	INFO("Enb0", usb_endpoint_num(ep->desc), ep->is_in, 0);
+out:
+	spin_unlock_irqrestore (&dev->lock, flags);
+	return rc;
+}
+
+static void
+__ep_set_halt_and_wedge(struct usb3380_ep *ep, int value, int wedged)
+{
+	DBG("Hlt0", value, wedged, 0);
+	/* set/clear, then synch memory views with the device */
+	if (value) {
+		ep->stopped = 1;
+		if (ep->num == 0) {
+			ep->dev->protocol_stall = 1;
+		} else {
+			if (ep->dma)
+				stop_dma (ep);
+			ep_stall (ep, true);
+		}
+		if (wedged)
+			ep->wedged = 1;
+	} else {
+		ep->stopped = 0;
+		ep->wedged = 0;
+		ep_stall (ep, false);
+		/* Flush the queue */
+		if (!list_empty(&ep->queue)) {
+			struct usb3380_request *req = list_entry(ep->queue.next,
+					struct usb3380_request, queue);
+			if (ep->dma)
+				resume_dma (ep);
+			else {
+				if (ep->is_in)
+					write_fifo(ep, &req->req);
+				else {
+					if (read_fifo(ep, req))
+						done (ep, req, 0);
+				}
+			}
+		}
+	}
+}
+
+static int
+usb3380_set_halt_and_wedge(struct usb3380_ep *ep, int value, int wedged)
+{
+	unsigned long flags;
+
+	if (!ep->desc && ep->num != 0)
+		return -EINVAL;
+	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+	if (ep->desc /* not ep0 */ &&
+			usb_endpoint_type(ep->desc) == USB_ENDPOINT_XFER_ISOC)
+		return -EINVAL;
+
+	if (!list_empty (&ep->queue))
+		return -EAGAIN;
+	else if (ep->is_in && value && usb3380_fifo_status (&ep->ep) != 0)
+		return -EAGAIN;
+
+	spin_lock_irqsave (&ep->dev->lock, flags);
+	if (wedged)
+		__ep_set_halt_and_wedge(ep, 1, 1);
+	else
+		__ep_set_halt_and_wedge(ep, value, 0);
+	spin_unlock_irqrestore (&ep->dev->lock, flags);
+
+	return 0;
+}
+
+static int
+usb3380_set_halt(struct usb_ep *_ep, int value)
+{
+	struct usb3380_ep *ep = container_of (_ep, struct usb3380_ep, ep);
+
+	if (!_ep) return -EINVAL;
+
+	return usb3380_set_halt_and_wedge(ep, value, 0);
+}
+
+static int
+usb3380_set_wedge(struct usb_ep *_ep)
+{
+	struct usb3380_ep *ep = container_of (_ep, struct usb3380_ep, ep);
+
+	if (!_ep || _ep->name == ep0name)
+		return -EINVAL;
+
+	return usb3380_set_halt_and_wedge(ep, 1, 1);
+}
+
+static const struct usb_ep_ops usb3380_ep_ops = {
+	/* configure endpoint, making it usable */
+	.enable		= usb3380_enable,
+	/* endpoint is no longer usable */
+	.disable	= usb3380_disable,
+
+	/* allocate a request object to use with this endpoint */
+	.alloc_request	= usb3380_alloc_request,
+	/* frees a request object */
+	.free_request	= usb3380_free_request,
+
+	/* queues (submits) an I/O request to an endpoint */
+	.queue		= usb3380_queue,
+	/* dequeues (cancels, unlinks) an I/O request from an endpoint */
+	.dequeue	= usb3380_dequeue,
+
+	/* sets the endpoint halt feature */
+	.set_halt	= usb3380_set_halt,
+	.set_wedge	= usb3380_set_wedge,
+	/* returns number of bytes in fifo, or error */
+	.fifo_status	= usb3380_fifo_status,
+	/* flushes contents of a fifo */
+	.fifo_flush	= usb3380_fifo_flush,
+};
+
+/*****************************************************************************/
+
+static void
+ep_reset(struct usb3380_regs __iomem *regs, struct usb3380_ep *ep)
+{
+	u32 tmp, dmastat;
+
+	ep->desc = NULL;
+	INIT_LIST_HEAD (&ep->queue);
+
+	ep->ep.maxpacket = ~0;
+	ep->ep.ops = &usb3380_ep_ops;
+
+	/* disable the dma, irqs, endpoint... */
+	if (ep->dma) {
+		/* In legacy mode, bit 1..4 correspond to the interrupt enable bits of
+		 * GPEP0..4
+		 * In enhanced mode, bit 1..4 correspond to the interrupt enable bits
+		 * of GPEP0..4 OUT, and bit 17..20 to GPEP0..4 IN
+		 */
+		writel (0, &ep->dma->dmactl);
+		writel ((1 << DMA_ABORT_DONE_INTERRUPT) |
+				(1 << DMA_PAUSE_DONE_INTERRUPT) |
+				(1 << DMA_LAST_DESCRIPTOR_DONE_INTERRUPT) |
+				(1 << DMA_TRANSACTION_DONE_INTERRUPT)
+				, &ep->dma->dmastat);
+
+		/* clear dmastat value to 0 when return value of dmastat is alaways 0x5002 */
+		dmastat=readl (&ep->dma->dmastat);
+		//VLOG("EpRt", dmastat, 0, 0);
+		if (dmastat == 0x5002) {
+			printk(KERN_WARNING "The dmastat return = %x!!\n", dmastat);
+			writel( 0x5a, &ep->dma->dmastat);
+		}
+
+		tmp = readl (&regs->pciirqenb0);
+		tmp &= ~(1 << PCIIRQBit(ep->num));
+		writel (tmp, &regs->pciirqenb0);
+	} else {
+		/* In enhanced mode DMA channels are used in ep1,2,3,4 only) */
+		if (ep->num < 5) {
+			tmp = readl (&regs->pciirqenb1);
+			/* make sure the DMA channel is disabled */
+			tmp &= ~(1 << (8 + ep->num));
+			writel (tmp, &regs->pciirqenb1);
+		}
+	}
+	writel (0, &ep->regs->ep_irqenb);
+
+	usb3380_set_halt_and_wedge(ep, 0, 0);
+	/* scrub most status bits, and flush any fifo state */
+	writel ((1 << SHORT_OUT_PACKET_DONE_INTERRUPT) |
+			(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+			(1 << ZLP_INTERRUPT) |
+			(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
+			(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
+			(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+			(1 << DATA_IN_TOKEN_INTERRUPT)
+			, &ep->regs->ep_stat);
+}
+
+static void usb_reinit (struct usb3380 *dev)
+{
+	int i, tmp;
+	int j;
+	u32 Scratch, FsmValue;
+
+	INIT_LIST_HEAD (&dev->gadget.ep_list);
+	dev->gadget.ep0 = &dev->ep[0].ep;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->gadget.max_speed = USB_SPEED_SUPER;
+	dev->ep[0].stopped = 0;
+
+	for (i = 0; i <= ep_count; i++) {
+		struct usb3380_ep *ep = &dev->ep[i];
+		
+		ep->num = i;
+		ep->ep.name = ep_name[enhanced][i];
+
+		ep->ep.ops = &usb3380_ep_ops;
+		list_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);
+		ep->dev = dev;
+		INIT_LIST_HEAD (&ep->queue);
+
+		/* EP0 and GPEPx Registers: See the header file for detail info */
+		/* In Legacy Adapter mode, only the OUT register offset is used to
+		 * access the corresponding register, although the endpoint can be
+		 * programmed as IN or OUT
+		 */
+		if (enhanced) {
+			u32 offset;
+			if (i > 4){
+				j=i-4;
+				offset = (((i != 0) && (i % 2 != 0))  ? 0 : 0xC0);
+			} else {
+				offset = (i == 0) ? 0:(((i != 0) && (i % 2 == 0))  ? 0 : 0xC0);
+				j=i;
+			}
+	
+			ep->cfg = &dev->epcfg[j];
+			ep->regs = (struct usb3380_ep_regs __iomem *)
+        			(((unsigned char *)&dev->epregs[j]) + offset);
+			ep->ffregs = &dev->ffregs[j];
+		} else {
+			ep->cfg = &dev->epcfg[i];
+			ep->regs = &dev->epregs[i];
+			ep->ffregs = &dev->ffregs[i];
+		}
+
+		/* We only have 4 channels */
+		if (use_dma && i > 0 && i <= NR_DMA_CHANNEL) {
+			ep->dma = &dev->dma[i-1];
+			ep->dmap = &dev->dmap[i-1];
+		}
+
+		ep_reset(dev->regs, ep);
+	}
+
+	dev->ep[0].fifo_size = 0x200;
+	dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
+	list_del_init (&dev->ep[0].ep.ep_list);
+
+	/* Link layer set up */
+
+	Scratch = get_idx_reg (dev->regs, SCRATCH);
+	FsmValue = Scratch & (0xf << DEFECT7374_FSM_FIELD);
+
+	/* See if driver needs to set up for workaround: */
+	if (FsmValue != DEFECT7374_FSM_SS_CONTROL_READ){
+		DBGMSG(dev, "%s: Defect 7374 FsmValue %08x \n", __FUNCTION__ , FsmValue);
+	} else {
+		tmp = readl(&dev->usb->usbctl2) &
+			~((1 << U1_ENABLE) | (1 << U2_ENABLE) | (1 << LTM_ENABLE));
+		writel(tmp, &dev->usb->usbctl2);
+
+		/* AA: link layer initialization:
+		 * - See USB338x-AA Errata 3
+		 */
+		if (dev->chiprev == 0xaa){	
+			writel (((1 << PM_DIR_LINK_REJECT)|
+				(1<<PM_LGO_COLLISION_SEND_LAU) |
+            			(1<<PM_U1_AUTO_EXIT) |
+            			(1<<PM_U2_AUTO_EXIT) |
+	            		0), &dev->llregs->ll_general_ctrl1);
+		}
+
+		/* FIXME: Sometimes when the USB3380 is connected to a host, it flutuates
+		 * between super speed and high speed and finally become stable at high
+		 * speed. If that keeps happening. The following code is a potential
+		 * workaround
+		 */
+#if 0
+		/* Polarity inversion workaround */
+		tmp = (readl(&dev->llregs->ll_general_ctrl2) & ~(1 << SELECT_INVERT_LANE_POLARITY)) | (1 << FORCE_INVERT_LANE_POLARITY);
+		writel (tmp, &dev->llregs->ll_general_ctrl2);
+#endif
+
+		/* AA_AB Errata. Issue 4. Workaround for SuperSpeed USB
+		   Hot Reset Exit Handshake may Fail in Specific Case using
+		   Default Register Settings. Workaround for Enumeration test.
+		*/
+
+		tmp = (readl(&dev->ll_tsn_regs->ll_tsn_counters_2) & ~(0x1f << HOT_TX_NORESET_TS2)) | (0x10 << HOT_TX_NORESET_TS2);
+		writel (tmp, &dev->ll_tsn_regs->ll_tsn_counters_2);
+
+		tmp = (readl(&dev->ll_tsn_regs->ll_tsn_counters_3) & ~(0x1f << HOT_RX_RESET_TS2)) | (0x3 << HOT_RX_RESET_TS2);
+		writel (tmp, &dev->ll_tsn_regs->ll_tsn_counters_3);
+
+		/* Set Recovery Idle to Recover bit:
+	   		- On SS connections, setting Recovery Idle to Recover FMW improves
+	   		  link robustness with various hosts and hubs.
+	   		- It is safe to set for all connection speeds; all chip revisions.
+		*/
+		tmp = (readl(&dev->ll_chicken_reg->ll_tsn_chicken_bit)|(1<<RECOVERY_IDLE_TO_RECOVER_FMW));
+		writel (tmp, &dev->ll_chicken_reg->ll_tsn_chicken_bit);
+
+#ifdef USE_TUNE_LOOPHOST
+		/* Gadget zero support only one pair of loopback endpoints. We can enlarge
+	 	 * the first pair's fifo size to improve the performance.
+	 	 * Changing Fifo configuration to (4K 2K 1K 1K)
+	 	 */
+		{
+			u32 fsiz[4] = { FIFO_SIZE_4096, FIFO_SIZE_2048,
+						FIFO_SIZE_1024, FIFO_SIZE_1024 };
+			struct usb3380_ep *ep;
+			u32 ffreg;
+
+			for (i = 4; i >= 1; i--) {
+				ep = &dev->ep[i];
+				ffreg = (readl (&ep->ffregs->ep_fifo_size_base) &
+					~(0x7 << IN_FIFO_SIZE)) | (fsiz[i-1] << IN_FIFO_SIZE);
+				writel (ffreg, &ep->ffregs->ep_fifo_size_base);
+			}
+		}
+#endif
+
+		/* Explicitly disable the 6 dedicated endpoints */
+		tmp = 0x0d;
+		for (i = 0; i < 4; i+=2, tmp++) {
+			writel (tmp, &dev->dep[i].dep_cfg);
+			writel (tmp, &dev->dep[i+1].dep_cfg);
+		}
+		writel (0x0f, &dev->dep[4].dep_cfg);
+		writel (0x0c, &dev->dep[5].dep_cfg);
+	}
+}
+
+static void Defect7374_EnableDataEpsAtZero(struct usb3380 *dev);
+
+static void usb_reset (struct usb3380 *dev)
+{
+	u32 tmp;
+	u32 Scratch, FsmValue;
+
+	usb3380_led_init(dev);
+
+	Scratch = get_idx_reg (dev->regs, SCRATCH);
+	FsmValue = Scratch & (0xf << DEFECT7374_FSM_FIELD);
+
+	/* See if firmware needs to set up for workaround: */
+	if (FsmValue != DEFECT7374_FSM_SS_CONTROL_READ){
+		DBGMSG(dev, "%s: Defect 7374 FsmValue %08x \n", __FUNCTION__ , FsmValue);
+	} else {
+		/* disable automatic responses, and irqs */
+		writel (0, &dev->usb->stdrsp);
+		writel (0, &dev->regs->pciirqenb0);
+		writel (0, &dev->regs->pciirqenb1);
+	}
+
+	/* clear old dma and irq state */
+	for (tmp = 1; tmp <= ep_count; tmp++) {
+		struct usb3380_ep *ep = &dev->ep[tmp];
+
+		if (ep->dma) {
+			nuke(ep);
+		}
+	}
+	/* Clear pending status */
+	writel (~0, &dev->regs->irqstat0);
+	writel (~0, &dev->regs->irqstat1);
+
+	/* reset, and enable pci */
+
+	if (FsmValue == DEFECT7374_FSM_SS_CONTROL_READ){
+		tmp = readl (&dev->regs->devinit) |
+			(1 << FIFO_SOFT_RESET) |
+			(1 << USB_SOFT_RESET) |
+			(1 << PCI_ENABLE) |
+			(1 << M8051_RESET);
+		writel (tmp, &dev->regs->devinit);
+	}
+}
+
+/* when a driver is successfully registered, it will receive
+ * control requests including set_configuration(), which enables
+ * non-control requests.  then usb traffic follows until a
+ * disconnect is reported.  then a host may connect again, or
+ * the driver might get unbound.
+ */
+static void
+stop_activity (struct usb3380 *dev, struct usb_gadget_driver *driver)
+{
+	int i;
+
+	VLOG("StpA", 0, 0, 0);
+
+	/* don't disconnect if it's not connected */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+
+	/* stop hardware; prevent new request submissions;
+	 * and kill any outstanding requests.
+	 */
+	usb_reset (dev);
+	for (i = 0; i <= ep_count; i++)
+		nuke (&dev->ep [i]);
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock (&dev->lock);
+		driver->disconnect (&dev->gadget);
+		spin_lock (&dev->lock);
+	}
+
+	usb_reinit (dev);
+}
+
+static void ep0_start(struct usb3380 *dev)
+{
+	u32 Scratch = get_idx_reg (dev->regs, SCRATCH);
+	u32 FsmValue = Scratch & (0xf << DEFECT7374_FSM_FIELD);
+
+	if (FsmValue != DEFECT7374_FSM_SS_CONTROL_READ){
+		VLOG("E0ST", FsmValue, 0, 0);
+	}else{
+		writel ((1 << CLEAR_NAK_OUT_PACKETS_MODE) |
+				(1 << SET_EP_HIDE_STATUS_STAGE)
+				, &dev->epregs[0].ep_rsp);
+	}
+
+	/* enable irqs so we can see ep0 and general operation  */
+	writel ((1 << SETUP_PACKET_PCIE_INTERRUPT_ENABLE) |
+			(1 << ENDPOINT_0_PCIE_INTERRUPT_ENABLE)
+			, &dev->regs->pciirqenb0);
+
+	writel ((1 << GLOBAL_PCIE_INTERRUPT) |
+			(1 << ROOT_PORT_RESET_PCIE_INTERRUPT_ENABLE) |
+			(1 << SUSPEND_REQUEST_CHANGE_PCIE_INTERRUPT_ENABLE) |
+			(1 << VBUS_PCIE_INTERRUPT_ENABLE)
+			, &dev->regs->pciirqenb1);
+
+	/*
+	 * hardware optionally handles a bunch of standard requests
+	 * that the API hides from drivers anyway.  have it do so.
+	 * endpoint status/features are handled in software, to
+	 * help pass tests for some dubious behavior.
+	 */
+
+	writel ((1 << SET_TEST_MODE) |
+		//(1 << DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP) |
+		(1 << GET_DEVICE_STATUS) |
+		(1 << SET_ADDRESS) |
+		(1 << SET_SEL) |
+		(1 << SET_ISOCHRONOUS_DELAY) |
+		(1 << GET_INTERFACE_STATUS)
+		, &dev->usb->stdrsp);
+
+	dev->wakeup_enable = 1;
+	writel ((1 << USB_ROOT_PORT_WAKEUP_ENABLE) |
+			(dev->softconnect << USB_DETECT_ENABLE) |
+			(1 << REMOTE_WAKEUP_ENABLE)
+			, &dev->usb->usbctl);
+
+	(void) readl (&dev->usb->usbctl);
+}
+
+int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
+		int (*bind)(struct usb_gadget *))
+{
+	struct usb3380 *dev = usb3380_controller;
+	int	retval, i;
+
+	/* don't support low speed devices */
+	if (!driver
+			|| driver->max_speed < USB_SPEED_FULL
+			|| !bind || !driver->setup)
+		return -EINVAL;
+	if (!dev)
+		return -ENODEV;
+	if (dev->driver)
+		return -EBUSY;
+
+	for (i = 0; i <= ep_count; i++)
+		dev->ep[i].irqs = 0;
+
+	/* hook up the driver ... */
+	dev->softconnect = 1;
+	driver->driver.bus = NULL;
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+	retval = bind(&dev->gadget);
+	if (retval) {
+		DBGMSG(dev, "bind to driver %s --> %d\n", driver->driver.name, retval);
+		dev->driver = NULL;
+		dev->gadget.dev.driver = NULL;
+		return retval;
+	}
+
+	/* ... then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 */
+	usb3380_led_active (dev, 1);
+
+	Defect7374_EnableDataEpsAtZero(dev);
+	
+	ep0_start (dev);
+
+	DBGMSG(dev, "%s ready, usbctl %08x usbstat %08x stdrsp %08x\n",
+			driver->driver.name,
+			readl (&dev->usb->usbctl),
+			readl (&dev->usb->usbstat),
+			readl (&dev->usb->stdrsp));
+
+	return 0;
+}
+#ifndef USB_GADGET_NAPI
+EXPORT_SYMBOL(usb_gadget_probe_driver);
+#endif
+
+static int usb3380_pullup(struct usb_gadget *, int);
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+{
+	struct usb3380 *dev = usb3380_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver || !driver->unbind)
+		return -EINVAL;
+
+	spin_lock_irqsave (&dev->lock, flags);
+	stop_activity (dev, driver);
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	usb3380_pullup (&dev->gadget, 0);
+
+	driver->unbind (&dev->gadget);
+	dev->gadget.dev.driver = NULL;
+	dev->driver = NULL;
+
+	usb3380_led_active (dev, 0);
+
+	DBGMSG(dev, "unregistered driver '%s'\n", driver->driver.name);
+	return 0;
+}
+#ifndef USB_GADGET_NAPI
+EXPORT_SYMBOL (usb_gadget_unregister_driver);
+#endif
+
+/*****************************************************************************/
+static int usb3380_get_frame (struct usb_gadget *_gadget)
+{
+	struct usb3380 *dev;
+	unsigned long flags;
+	u16	retval;
+
+	if (!_gadget)
+		return -ENODEV;
+
+	dev = container_of (_gadget, struct usb3380, gadget);
+	spin_lock_irqsave (&dev->lock, flags);
+	/* Index 02h FRMAE frame counter 10:0 */
+	retval = get_idx_reg (dev->regs, IDXREG_FRAME) & 0x03ff;
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	return retval;
+}
+
+static int usb3380_wakeup (struct usb_gadget *_gadget)
+{
+	struct usb3380 *dev;
+	u32 tmp;
+	unsigned long flags;
+
+	if (!_gadget)
+		return 0;
+	dev = container_of (_gadget, struct usb3380, gadget);
+
+	spin_lock_irqsave (&dev->lock, flags);
+	tmp = readl (&dev->usb->usbctl);
+	if (tmp & (1 << REMOTE_WAKEUP_ENABLE))
+		writel (1 << GENERATE_RESUME, &dev->usb->usbstat);
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	return 0;
+}
+
+static int usb3380_set_selfpowered (struct usb_gadget *_gadget, int value)
+{
+	struct usb3380 *dev;
+	u32 tmp;
+	unsigned long flags;
+
+	if (!_gadget)
+		return 0;
+	dev = container_of (_gadget, struct usb3380, gadget);
+
+	spin_lock_irqsave (&dev->lock, flags);
+	tmp = readl (&dev->usb->usbctl);
+	if (value) {
+		tmp |= (1 << SELF_POWERED_STATUS);
+		dev->selfpowered = 1;
+	} else {
+		tmp &= ~(1 << SELF_POWERED_STATUS);
+		dev->selfpowered = 0;
+	}
+	writel (tmp, &dev->usb->usbctl);
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	return 0;
+}
+
+static int usb3380_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct usb3380 *dev;
+	u32             tmp;
+	unsigned long   flags;
+
+	if (!_gadget)
+		return -ENODEV;
+	dev = container_of (_gadget, struct usb3380, gadget);
+
+	spin_lock_irqsave (&dev->lock, flags);
+
+	/* Redetect the speed of the connection */
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	tmp = readl (&dev->usb->usbctl);
+	dev->softconnect = (is_on != 0);
+	if (is_on)
+		tmp |= (1 << USB_DETECT_ENABLE);
+	else
+		tmp &= ~(1 << USB_DETECT_ENABLE);
+	writel (tmp, &dev->usb->usbctl);
+	spin_unlock_irqrestore (&dev->lock, flags);
+
+	return 0;
+}
+
+static void Defect7374_DisableDataEps(struct usb3380 *dev){
+	/* For Defect 7374, disable data EPs (and more):
+	 *  - This phase undoes the earlier phase of the Defect 7374 workaround,
+	 *	  returing ep regs back to normal.
+	 */
+	struct usb3380_ep *ep;
+	int i;
+	unsigned char ep_sel;
+	u32 tmp_reg;
+
+	INFO("DefD", 0, 0, 0);
+	
+	for (i = 1; i < 5; i++) {
+		ep = &dev->ep[i];
+		writel (0, &ep->cfg->ep_cfg);
+	}
+
+	// CSROUT, CSRIN, PCIOUT, PCIIN, STATIN, RCIN
+	for (i = 0; i < 6; i++) {
+		writel (0, &dev->dep[i].dep_cfg);
+	}
+
+	for (ep_sel = 0; ep_sel <= 21; ep_sel++){
+
+		// Select an endpoint for subsequent operations:
+		tmp_reg = readl(&dev->plregs->pl_ep_ctrl);
+		writel (((tmp_reg & ~ 0x1f) | ep_sel), &dev->plregs->pl_ep_ctrl);
+
+		// Change settings on some selected endpoints
+		switch (ep_sel)
+		{
+			// Undo earlier protocol layer EP programming:
+			case 2:     // GPEP0 OUT
+			case 3:     // GPEP0 IN
+			case 4:     // GPEP1 OUT
+			case 5:     // GPEP1 IN
+			case 6:     // GPEP2 OUT
+			case 7:     // GPEP2 IN
+			case 8:     // GPEP3 OUT
+			case 9:     // GPEP3 IN
+			case 14:    // CSROUT
+			case 15:    // CSRIN
+			case 16:    // PCIOUT
+			case 17:    // PCIIN
+			case 19:    // STATIN
+			case 21:    // RCIN
+				writel ((readl(&dev->plregs->pl_ep_cfg_4) & ~(1 << NON_CTRL_IN_TOLERATE_BAD_DIR)), &dev->plregs->pl_ep_cfg_4);
+				writel ((readl(&dev->plregs->pl_ep_ctrl) | (1 << EP_INITIALIZED)), &dev->plregs->pl_ep_ctrl);
+				break;
+		}
+	}
+}
+
+static void Defect7374_EnableDataEpsAtZero(struct usb3380 *dev){
+	u32 tmp=0, tmp_reg;
+	u32 Scratch = get_idx_reg (dev->regs, SCRATCH);
+	u32 FsmValue = Scratch & (0xf << DEFECT7374_FSM_FIELD);
+	int i;
+	unsigned char ep_sel;
+	
+
+	Scratch &= ~(0xf << DEFECT7374_FSM_FIELD);
+	///See if firmware needs to set up for workaround:
+	if (FsmValue != DEFECT7374_FSM_SS_CONTROL_READ)
+	{
+		printk(KERN_WARNING "Operate Defect 7374 workaround software this time. (It will operate on cold-reboot and SS connection.)\n");
+		//GPEPs:
+
+		tmp = (
+				(0<<ENDPOINT_NUMBER) |
+				(1<<ENDPOINT_DIRECTION) |
+				(2<<OUT_ENDPOINT_TYPE) |
+				((enhanced)? 0<<OUT_ENDPOINT_ENABLE: 1<<ENDPOINT_ENABLE) |
+				(2<<IN_ENDPOINT_TYPE) |
+				(1<<IN_ENDPOINT_ENABLE) |
+				0);
+
+		for (i = 1; i < 5; i++) {
+			struct usb3380_ep *ep = &dev->ep[i];
+			writel (tmp, &ep->cfg->ep_cfg);
+		}
+
+		// CSRIN, PCIIN, STATIN, RCIN
+		tmp = ((0 << ENDPOINT_NUMBER) | (1 << ENDPOINT_ENABLE));
+		writel (tmp, &dev->dep[1].dep_cfg);
+		writel (tmp, &dev->dep[3].dep_cfg);
+		writel (tmp, &dev->dep[4].dep_cfg);
+		writel (tmp, &dev->dep[5].dep_cfg);		
+
+		//XXXXXXXXXXXXX Implemented for development and debug. Can be refined/tuned later.
+		for (ep_sel = 0; ep_sel <= 21; ep_sel++){
+
+			// Select an endpoint for subsequent operations:
+			tmp_reg = readl(&dev->plregs->pl_ep_ctrl);
+			writel (((tmp_reg & ~ 0x1f) | ep_sel), &dev->plregs->pl_ep_ctrl);
+	
+			// Change settings on some selected endpoints
+			switch (ep_sel)
+			{
+				case 1:     // EP0 IN
+					writel ((readl(&dev->plregs->pl_ep_ctrl)| (1<<CLEAR_ACK_ERROR_CODE) |
+						0), &dev->plregs->pl_ep_ctrl);
+					break;
+				// Allow all EPs except control EP (EP0) to tolerate bad direction:
+				case 2:     // GPEP0 OUT
+				case 3:     // GPEP0 IN
+				case 4:     // GPEP1 OUT
+				case 5:     // GPEP1 IN
+				case 6:     // GPEP2 OUT
+				case 7:     // GPEP2 IN
+				case 8:     // GPEP3 OUT
+				case 9:     // GPEP3 IN
+				case 14:    // CSROUT
+				case 15:    // CSRIN
+				case 16:    // PCIOUT
+				case 17:    // PCIIN
+				case 19:    // STATIN
+				case 21:    // RCIN
+					writel ((readl(&dev->plregs->pl_ep_cfg_4) | (1 << NON_CTRL_IN_TOLERATE_BAD_DIR) |
+						0), &dev->plregs->pl_ep_cfg_4);
+					writel ((readl(&dev->plregs->pl_ep_ctrl) & ~(1 << EP_INITIALIZED)), &dev->plregs->pl_ep_ctrl);
+
+					break;
+			}
+		}
+
+		// Set FSM to focus on the first Control Read:
+		//  - Tip: Connection speed is known upon the first setup request.
+		Scratch |= DEFECT7374_FSM_WAITING_FOR_CONTROL_READ;
+		set_idx_reg (dev->regs, SCRATCH, Scratch);
+	} else {
+		printk(KERN_WARNING "Defect 7374 workaround software will NOT operate this time. (It will operate on cold-reboot and SS connection.)\n");
+	}
+	
+	INFO("DefE", FsmValue, Scratch, 0);
+}
+
+static const struct usb_gadget_ops usb3380_ops = {
+	/* returns the current frame number */
+	.get_frame	= usb3380_get_frame,
+	/* tries to wake up the host connected to this gadget */
+	.wakeup		= usb3380_wakeup,
+	/* sets the device selfpowered feature */
+	.set_selfpowered = usb3380_set_selfpowered,
+	.pullup		= usb3380_pullup,
+#ifdef USB_GADGET_NAPI
+	.start		= usb_gadget_probe_driver,
+	.stop		= usb_gadget_unregister_driver,
+#endif
+};
+
+static void gadget_release (struct device *_dev)
+{
+	struct usb3380 *dev = dev_get_drvdata(_dev);
+	kfree (dev);
+}
+
+/*****************************************************************************/
+static struct usb3380_ep *
+get_ep_by_addr (struct usb3380 *dev, u16 wIndex)
+{
+	struct usb3380_ep	*ep;
+
+	if ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)
+		return &dev->ep [0];
+	list_for_each_entry (ep, &dev->gadget.ep_list, ep.ep_list) {
+		u8	bEndpointAddress;
+
+		if (!ep->desc)
+			continue;
+		bEndpointAddress = ep->desc->bEndpointAddress;
+		if ((wIndex ^ bEndpointAddress) & USB_DIR_IN)
+			continue;
+		if ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))
+			return ep;
+	}
+	return NULL;
+}
+
+/* handle endpoints in pio mode or just to manually
+ * advance the queue after short OUT transfers.
+ */
+static void handle_ep_intr (struct usb3380_ep *ep)
+{
+	struct usb3380_request	*req;
+	volatile u32 t;
+	/* 0 error, 1 mid-data, 2 done */
+	int mode = 1;
+	u32 tmp_val;
+
+	if (!list_empty (&ep->queue))
+		req = list_entry (ep->queue.next, struct usb3380_request, queue);
+	else
+		req = NULL;
+
+	/* ack all, and handle what we care about */
+	t = readl (&ep->regs->ep_stat);
+	ep->irqs++;
+
+	DBG("Intr", ep->num, ep->is_in, t);
+
+	if (ep->is_in)
+		writel (t, &ep->regs->ep_stat);
+
+	/* for ep0, monitor token irqs to catch data stage length errors
+	 * and to synchronize on status.
+	 *
+	 * also, to defer reporting of protocol stalls ... here's where
+	 * data or status first appears, handling stalls here should never
+	 * cause trouble on the host side..
+	 *
+	 * control requests could be slightly faster without token synch for
+	 * status, but status can jam up that way.
+	 */
+
+	VLOG("Int0", ep->dev->protocol_stall, ep->stopped, (u32)req);
+
+	if (unlikely (ep->num == 0)) {
+		if (ep->is_in) {
+			/* status; stop NAKing */
+			if (t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)) {
+				if (ep->dev->protocol_stall) {
+					ep->stopped = 1;
+					ep_stall (ep, true);
+				}
+				if (!req) {
+					allow_status (ep);
+				}
+				mode = 2;
+			/* reply to extra IN data tokens with a zlp */
+			} else if (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {
+				if (ep->dev->protocol_stall) {
+					ep->stopped = 1;
+					ep_stall (ep, true);
+					mode = 2;
+				} else if (ep->responded && !req && !ep->stopped) {
+					VLOG("Rsbd", 0, 0, 0);
+					write_fifo (ep, NULL);
+				}
+			}
+		} else {
+			/* status; stop NAKing */
+			if (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {
+				if (ep->dev->protocol_stall) {
+					ep->stopped = 1;
+					ep_stall (ep, true);
+				}
+				mode = 2;
+			/* an extra OUT token is an error */
+			} else if (((t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT))
+					&& req
+					&& req->req.actual == req->req.length)
+					|| (ep->responded && !req)) {
+				VLOG("DOPT", ep->responded, req ? req->req.actual: 0,
+						req ? req->req.length: 0);
+				ep->dev->protocol_stall = 1;
+				ep->stopped = 1;
+				ep_stall (ep, true);
+				if (req)
+					done (ep, req, -EOVERFLOW);
+				req = NULL;
+			}
+		}
+
+#if 1
+		/* Enable interrupts here. */
+		writel ((1 << SHORT_OUT_PACKET_DONE_INTERRUPT) |
+		                                (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+		                                (1 << DATA_PACKET_RECEIVED_INTERRUPT) |
+		                                (1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
+		                                (1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+		                                (1 << DATA_IN_TOKEN_INTERRUPT)
+		                                , &ep->regs->ep_stat);
+#endif
+
+	}
+
+	if (unlikely (!req))
+		goto out;
+
+	/* manual DMA queue advance after short OUT */
+	if (likely (ep->dma != 0)) {
+//		writel (t & ~(1 << NAK_PACKETS), &ep->regs->ep_stat);
+		if ((t & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)) && ((t &(1 << SHORT_OUT_PACKET_DONE_INTERRUPT))==0)) {
+			WARNING("SOUT", ep->num, t, 0);
+		}
+		if (t & (1 << SHORT_OUT_PACKET_DONE_INTERRUPT)) {
+		//if (t & (1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT)) {
+			int	stopped = ep->stopped;
+			ep->stopped = 1;
+
+			/* 10.4 DMA OUT Transfer Completion
+			 * software polls the FIFO Empty status flag until the FIFO
+			 * indicates there's no remaining data.
+			 */
+			//while (!(readl(&ep->regs->ep_stat) & (1 << FIFO_EMPTY)));
+			/* DMA transfer is complete, data has been in the buffer now. */
+			/* stop DMA, leave ep NAKing */
+#if 1
+			tmp_val = readl(&ep->regs->ep_stat);
+			if (((tmp_val & (1 << FIFO_EMPTY))==0)||((tmp_val & (1 << NAK_PACKETS))==0))
+			/* Possibly data in fifo has been transferred by DMA, 
+ 			 * the NAK_PACKETS bit has been cleared by DMA. 
+ 			 * The succeding data is comming to fifo.*/
+				printk(KERN_WARNING "got short out done but fifo not empty! ep_stat_old=%x ep_stat=%x ep_avail=%x\n", t, tmp_val, readl (&ep->regs->ep_avail));
+#endif
+
+			abort_dma(ep);
+			scan_dma_completions (ep);
+			ep->stopped = stopped;
+			/* (re)start dma if needed, stop NAKing */
+			/* A possible cause of short packet received before queuing dma.
+ 			 * Stop NAKing here rather than before abort dma.
+ 			 */ 
+			writel (t & ~(1 << NAK_PACKETS), &ep->regs->ep_stat);
+			if (!list_empty (&ep->queue))
+				restart_dma (ep);
+		}
+		return;
+	} else
+	/* data packet(s) received (in the fifo, OUT) */
+	if (t & (1 << DATA_PACKET_RECEIVED_INTERRUPT)) {
+		if (read_fifo (ep, req) && ep->num != 0)
+			mode = 2;
+
+		/* These states has been taken care of in the read_fifo */
+		t &= ~((1 << ZLP_INTERRUPT) |
+				(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+				(1 << SHORT_OUT_PACKET_DONE_INTERRUPT));
+
+	/* data packet(s) transmitted (IN) */
+	} else if (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)) {
+		unsigned	len;
+
+		len = req->req.length - req->req.actual;
+		if (len > ep->ep.maxpacket)
+			len = ep->ep.maxpacket;
+		req->req.actual += len;
+
+		DBG("Xmit", req->req.actual, req->req.length, len);
+
+		/* if we wrote it all, we're usually done */
+		if (req->req.actual == req->req.length) {
+			if (ep->num == 0) {
+				/* send zlps until the status stage */
+			} else if (!req->req.zero || len != ep->ep.maxpacket)
+				mode = 2;
+		}
+
+	/* there was nothing to do ...  */
+	} else if (mode == 1)
+		goto out;
+
+	/* done */
+	if (mode == 2) {
+		/* stream endpoints often resubmit/unlink in completion */
+		done (ep, req, 0);
+
+		/* maybe advance queue to next request */
+		if (ep->num == 0) {
+			/* NOTE:  usb3380 could let gadget driver start the
+			 * status stage later. since not all controllers let
+			 * them control that, the api doesn't (yet) allow it.
+			 */
+			if (!ep->stopped) {
+				allow_status (ep);
+			}
+			req = NULL;
+			goto out;
+		} else {
+			if (!list_empty (&ep->queue) && !ep->stopped)
+				req = list_entry (ep->queue.next,
+					struct usb3380_request, queue);
+			else
+				req = NULL;
+			if (req && !ep->is_in) {
+				VLOG("SNak", ep->num, req->req.actual, req->req.length);
+				stop_out_naking (ep);
+			}
+		}
+	}
+
+	/* is there a buffer for the next packet?
+	 * for best streaming performance, make sure there is one.
+	 */
+	if (req && !ep->stopped) {
+		/* load IN fifo with next packet (may be zlp) */
+		if (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT))
+			write_fifo (ep, &req->req);
+	}
+
+	return;
+out:
+	if (!ep->is_in)
+		writel (t & ~(1 << NAK_PACKETS), &ep->regs->ep_stat);
+}
+
+#define DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS         200
+#define DEFECT_7374_PROCESSOR_WAIT_TIME             10
+
+static void handle_stat0_irqs (struct usb3380 *dev, u32 stat)
+{
+	struct usb3380_ep *ep;
+	u32 num, scratch;
+	u32 Scratch, FsmValue;
+	u32 AckWaitTimeout, State;
+
+	/* most of these don't need individual acks */
+	stat &= ~(1 << INTA_ASSERTED);
+	if (!stat)
+		return;
+
+	DBG("Ist0", stat, 0, 0);
+
+	/* starting a control request? */
+	if (unlikely (stat & (1 << SETUP_PACKET_INTERRUPT_STATUS))) {
+		union {
+			u32 raw[2];
+			struct usb_ctrlrequest r;
+		} u;
+		int	tmp = 0;
+		struct usb3380_request *req;
+		u16 status;
+
+		if (dev->gadget.speed == USB_SPEED_UNKNOWN) {
+			u32 val = readl (&dev->usb->usbstat);
+			if (val & (1 << SUPER_SPEED_MODE)) {
+				dev->gadget.speed = USB_SPEED_SUPER;
+				dev->ep[0].ep.maxpacket = EP0_SS_MAX_PACKET_SIZE;
+			} else if (val & (1 << HIGH_SPEED_MODE)) {
+				dev->gadget.speed = USB_SPEED_HIGH;
+				dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
+			} else {
+				dev->gadget.speed = USB_SPEED_FULL;
+				dev->ep[0].ep.maxpacket = EP0_HS_MAX_PACKET_SIZE;
+			}
+			usb3380_led_speed (dev, dev->gadget.speed);
+			INFO("CSpd", dev->gadget.speed, 0, 0);
+		}
+
+		ep = &dev->ep [0];
+		ep->irqs++;
+
+		/* make sure any leftover request state is cleared */
+		// Clear later!!
+		//stat &= ~(1 << ENDPOINT_0_INTERRUPT_STATUS);
+		while (!list_empty (&ep->queue)) {
+			req = list_entry (ep->queue.next, struct usb3380_request, queue);
+			done (ep, req, (req->req.actual == req->req.length)
+						? 0 : -EPROTO);
+		}
+
+		ep->stopped = 0;
+		ep->is_halt = 0;
+		dev->protocol_stall = 0;
+
+		/* Intterupts has been enabled in eariler stage. */
+		/* TD9.10 BAD descriptor test */
+#if 0
+		writel ((1 << SHORT_OUT_PACKET_DONE_INTERRUPT) |
+				(1 << SHORT_OUT_PACKET_RECEIVED_INTERRUPT) |
+				(1 << DATA_PACKET_RECEIVED_INTERRUPT) |
+				(1 << DATA_PACKET_TRANSMITTED_INTERRUPT) |
+				(1 << DATA_OUT_PING_TOKEN_INTERRUPT) |
+				(1 << DATA_IN_TOKEN_INTERRUPT)
+				, &ep->regs->ep_stat);
+#endif
+
+		u.raw [0] = readl (&dev->usb->setupdw0);
+		u.raw [1] = readl (&dev->usb->setupdw1);
+
+		cpu_to_le32s (&u.raw [0]);
+		cpu_to_le32s (&u.raw [1]);
+
+#define	w_value		le16_to_cpu(u.r.wValue)
+#define	w_index		le16_to_cpu(u.r.wIndex)
+#define	w_length	le16_to_cpu(u.r.wLength)
+
+		/* Workaround for Defect 7374 (U1/U2 erroneously rejected): */
+		Scratch = get_idx_reg (dev->regs, SCRATCH); 
+		FsmValue = Scratch & 0xf << DEFECT7374_FSM_FIELD;
+
+		Scratch &= ~(0xf << DEFECT7374_FSM_FIELD);
+
+		if ((FsmValue == DEFECT7374_FSM_WAITING_FOR_CONTROL_READ) &&
+			(u.r.bRequestType & USB_DIR_IN)){
+			/* This is the first Control Read for this connection: */
+			if (readl(&dev->usb->usbstat) & ( 1 << SUPER_SPEED_MODE)){   
+			// Connection is SS:
+
+				for (AckWaitTimeout = 0; AckWaitTimeout < DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS; AckWaitTimeout++){
+
+					State = readl(&dev->plregs->pl_ep_status_1) & (0xff << STATE);
+
+					if ((State >= (ACK_GOOD_NORMAL<<STATE)) && (State <= (ACK_GOOD_MORE_ACKS_TO_COME<<STATE))){
+						Scratch |= DEFECT7374_FSM_SS_CONTROL_READ;
+						break;
+					}
+
+					// We have not yet received host's Data Phase ACK
+					//  - Wait and try again.
+					udelay(DEFECT_7374_PROCESSOR_WAIT_TIME);
+					continue;
+				}
+				
+				INFO("DefA", AckWaitTimeout, State, Scratch);
+				printk(KERN_INFO "INFO: Defect 7374 workaround waited about %duSec for Control Read Data Phase ACK\n", DEFECT_7374_PROCESSOR_WAIT_TIME*AckWaitTimeout);
+		
+				if (AckWaitTimeout >= DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS)
+					printk(KERN_WARNING "FAIL: Defect 7374 workaround waited but failed to detect SS host's data phase ACK. PL_EP_STATUS_1(23:16): Expected from 0x11 to 0x16 got 0x%2.2x.\n", State>>STATE);
+			} else {
+				// Connection is NOT SS:
+				//  - Connection must be FS or HS.
+				//  - This FSM state should allow workaround software to
+				// run after the next USB connection.
+				Scratch |= DEFECT7374_FSM_NON_SS_CONTROL_READ;
+			}
+
+			// Restore data EPs to their pre-workaround settings (disabled,
+			// initialized, and other details).
+			Defect7374_DisableDataEps(dev);
+			set_idx_reg (dev->regs, SCRATCH, Scratch);
+		}
+
+		INFO("DefS", 0, FsmValue, Scratch);
+
+		/* ack the irq */
+		writel (1 << SETUP_PACKET_INTERRUPT_STATUS, &dev->regs->irqstat0);
+		stat ^= (1 << SETUP_PACKET_INTERRUPT_STATUS);
+
+		/* watch control traffic at the token level, and force
+		 * synchronization before letting the status stage happen.
+		 * FIXME ignore tokens we'll NAK, until driver responds.
+		 * that'll mean a lot less irqs for some drivers.
+		 */
+		ep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;
+		if (ep->is_in) {
+			scratch = (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE) |
+				(1 << DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE) |
+				(1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);
+			stop_out_naking (ep);
+		} else
+			scratch = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |
+				(1 << DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE) |
+				(1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);
+
+		writel (scratch, &dev->epregs [0].ep_irqenb);
+
+		/* we made the hardware handle most lowlevel requests;
+		 * everything else goes uplevel to the gadget code.
+		 */
+		ep->responded = 1;
+		switch (u.r.bRequest) {
+			struct usb3380_ep *e;
+
+			case USB_REQ_SET_CONFIGURATION:
+				if (w_value == 0)
+					dev->addressed_state = true;
+				else
+					dev->addressed_state = false;
+				goto delegate;
+			
+			case USB_REQ_GET_STATUS:
+
+			switch (u.r.bRequestType) {
+				case (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
+					status = dev->wakeup_enable ? 0x02 : 0x00;
+					if (dev->selfpowered)
+						status |= 1<<0;
+					if (dev->gadget.speed == USB_SPEED_SUPER)
+						status |= (
+								dev->u1_enable << 2 |
+								dev->u2_enable << 3 |
+								dev->ltm_enable << 4);
+					else if (dev->wakeup_enable)
+						status |= 0x01;
+
+					writel (0, &dev->epregs[0].ep_irqenb);
+					set_fifo_bytecount(ep, sizeof(status));
+					writel ((__force u32)status, &dev->epregs[0].ep_data);
+					VLOG("Spk0", status, 0, 0);
+					allow_status(ep);
+					break;
+
+				case (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
+					e = get_ep_by_addr (dev, w_index);
+					if (!e) goto do_stall;
+					
+					status = readl (&e->regs->ep_rsp) &
+						(1 << CLEAR_ENDPOINT_HALT);
+					
+					writel (0, &dev->epregs[0].ep_irqenb);
+					set_fifo_bytecount(ep, sizeof(status));
+					writel ((__force u32)status, &dev->epregs[0].ep_data);
+					allow_status(ep);
+					VLOG("Spk0", status, 0, 0);
+					break;
+
+				default:
+					goto delegate;
+			}
+			break;
+
+			case USB_REQ_CLEAR_FEATURE:
+
+			switch (u.r.bRequestType) {
+				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
+					if (dev->gadget.speed == USB_SPEED_SUPER &&
+						   !dev->addressed_state) {
+						switch (w_value) {
+							case USB_DEVICE_U1_ENABLE:
+								dev->u1_enable = 0;
+								writel (readl(&dev->usb->usbctl2) &
+										~(1 << U1_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							case USB_DEVICE_U2_ENABLE:
+								dev->u2_enable = 0;
+								writel (readl(&dev->usb->usbctl2) &
+										~(1 << U2_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							case USB_DEVICE_LTM_ENABLE:
+								dev->ltm_enable = 0;
+								writel (readl(&dev->usb->usbctl2) &
+										~(1 << LTM_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							default:
+								break;
+						}
+					}
+					if (w_value == USB_DEVICE_REMOTE_WAKEUP) {
+						dev->wakeup_enable = 0;
+						writel (readl(&dev->usb->usbctl) &
+								~(1 << REMOTE_WAKEUP_ENABLE)
+								, &dev->usb->usbctl);
+						allow_status(ep);
+						break;
+					}
+					goto delegate;
+
+				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
+					e = get_ep_by_addr (dev, w_index);
+					if (!e) goto do_stall;
+
+					if (w_value != USB_ENDPOINT_HALT)
+						goto do_stall;
+
+					__ep_set_halt_and_wedge(e, false, false);
+					allow_status(ep);
+					break;
+
+				default:
+					goto delegate;
+			}
+			break;
+
+			case USB_REQ_SET_FEATURE:
+
+			switch (u.r.bRequestType) {
+				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):
+					if (dev->gadget.speed == USB_SPEED_SUPER &&
+						   !dev->addressed_state) {
+						switch (w_value) {
+							case USB_DEVICE_U1_ENABLE:
+								dev->u1_enable = 1;
+								writel (readl(&dev->usb->usbctl2) |
+										(1 << U1_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							case USB_DEVICE_U2_ENABLE:
+								dev->u2_enable = 1;
+								writel (readl(&dev->usb->usbctl2) |
+										(1 << U2_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							case USB_DEVICE_LTM_ENABLE:
+								dev->ltm_enable = 1;
+								writel (readl(&dev->usb->usbctl2) |
+										(1 << LTM_ENABLE)
+										, &dev->usb->usbctl2);
+								allow_status(ep);
+								goto next_endpoints;
+							default:
+								break;
+						}
+					}
+					if (w_value == USB_DEVICE_REMOTE_WAKEUP) {
+						dev->wakeup_enable = 1;
+						writel (readl(&dev->usb->usbctl) |
+								(1 << REMOTE_WAKEUP_ENABLE)
+								, &dev->usb->usbctl);
+						allow_status(ep);
+						break;
+					}
+					goto delegate;
+
+				case (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
+					e = get_ep_by_addr (dev, w_index);
+					if (!e) goto do_stall;
+
+					if (w_value != USB_ENDPOINT_HALT)
+						goto do_stall;
+
+					__ep_set_halt_and_wedge(e, true, false);
+					allow_status(ep);
+					break;
+
+				default:
+					goto delegate;
+			}
+			break;
+
+			default:
+delegate:
+			VLOG("Spk4", u.r.bRequestType, u.r.bRequest, w_value);
+			VLOG("Spk5", w_index, w_length, readl(&ep->cfg->ep_cfg));
+			ep->responded = 0;
+			spin_unlock (&dev->lock);
+			tmp = dev->driver->setup (&dev->gadget, &u.r);
+			spin_lock (&dev->lock);
+		}
+
+		/* stall ep0 on error */
+		if (tmp < 0) {
+do_stall:
+			DBG("Stal", u.r.bRequestType, u.r.bRequest, tmp);
+			dev->protocol_stall = 1;
+
+			/* TD 9.9 Halt Endpoint test. TD 9.22 Set feature test */
+			ep_stall (ep, true);
+			//ep->responded = 1;
+		}
+
+		/* some in/out token irq should follow; maybe stall then.
+		 * driver must queue a request (even zlp) or halt ep0
+		 * before the host times out.
+		 */
+	}
+
+#undef	w_value
+#undef	w_index
+#undef	w_length
+
+next_endpoints:
+	/* endpoint 0, GPEPx (out if enhanced)  */
+	scratch = stat & 0x1f;
+	stat &= ~0x1f;
+	for (num = 0; scratch; num++) {
+		u32 t;
+		/* do this endpoint's FIFO and queue need tending? */
+		t = 1 << num;
+		if ((scratch & t) == 0)
+			continue;
+		scratch ^= t;
+
+		if (num == 0)
+			ep = &dev->ep[0];
+		else
+			ep = (enhanced) ? &dev->ep [num + ((num % 2)*4)] : &dev->ep [num];
+
+		handle_ep_intr (ep);
+	}
+	/* Bit 17..20 for GPEPx in */
+	scratch = (stat & 0x1e0000) >> 16;
+	stat &= ~0x1e0000;
+	for (num = 1; enhanced && scratch; num++) {
+		u32 t = 1 << num;
+		if ((scratch & t) == 0)
+			continue;
+		scratch ^= t;
+		
+		ep = &dev->ep[num + (((num - 1) % 2)*4)];
+
+		handle_ep_intr (ep);
+	}
+
+	/* TD 9.9 Halt Endpoint test. TD 9.22 Set feature test */
+//	ep->responded = 0;
+
+	if (stat)
+		WARNING("Uis0", stat, 0, 0);
+}
+
+#define DMA_INTERRUPTS ( \
+		  (1 << DMA_3_INTERRUPT) \
+		| (1 << DMA_2_INTERRUPT) \
+		| (1 << DMA_1_INTERRUPT) \
+		| (1 << DMA_0_INTERRUPT))
+
+#define	PCI_ERROR_INTERRUPTS ( \
+		  (1 << PCI_MASTER_ABORT_RECEIVED_INTERRUPT) \
+		| (1 << PCI_TARGET_ABORT_RECEIVED_INTERRUPT))
+
+static void handle_stat1_irqs (struct usb3380 *dev, u32 stat)
+{
+	struct usb3380_ep *ep;
+	u32 num, mask, scratch, tmp;
+
+	/* after disconnect there's nothing else to do! */
+	tmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);
+	mask = (1 << SUPER_SPEED_MODE) |
+		(1 << HIGH_SPEED_MODE) | (1 << FULL_SPEED_MODE);
+
+	/* VBUS disconnect is indicated by VBUS_PIN and VBUS_INTERRUPT set.
+	 * Root Port Reset is indicated by ROOT_PORT_RESET_INTERRRUPT set and
+	 * both HIGH_SPEED and FULL_SPEED clear (as ROOT_PORT_RESET_INTERRUPT
+	 * only indicates a change in the reset state).
+	 */
+	if (stat & tmp) {
+		writel (tmp, &dev->regs->irqstat1);
+		if ((((stat & (1 << ROOT_PORT_RESET_INTERRUPT))
+					&& ((readl (&dev->usb->usbstat) & mask) == 0)) ||
+			((readl (&dev->usb->usbctl) & (1 << VBUS_PIN)) == 0)) &&
+			    (dev->gadget.speed != USB_SPEED_UNKNOWN)) {
+			INFO("Dsct", 0, 0, 0);
+			stop_activity (dev, dev->driver);
+			ep0_start (dev);
+			return;
+		}
+		stat &= ~tmp;
+
+		/* vBUS can bounce ... one of many reasons to ignore the
+		 * notion of hotplug events on bus connect/disconnect!
+		 */
+		if (!stat)
+			return;
+	}
+
+	/* NOTE: chip stays in PCI D0 state for now, but it could
+	 * enter D1 to save more power
+	 */
+	tmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);
+	if (stat & tmp) {
+		writel (tmp, &dev->regs->irqstat1);
+		if (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {
+			if (dev->driver->suspend)
+				dev->driver->suspend (&dev->gadget);
+			if (!enable_suspend)
+				stat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);
+		} else {
+			if (dev->driver->resume)
+				dev->driver->resume (&dev->gadget);
+			/* at high speed, note erratum 0133 */
+		}
+		stat &= ~tmp;
+	}
+
+	/* clear any other status/irqs */
+	if (stat)
+		writel (stat, &dev->regs->irqstat1);
+
+	/* some status we can just ignore */
+	stat &= ~((1 << CONTROL_STATUS_INTERRUPT)
+			  | (1 << RESUME_INTERRUPT)
+			  | (1 << SOF_DOWNCOUNT_INTERRUPT)
+			  | (1 << SOF_INTERRUPT));
+
+	if (!stat)
+		return;
+
+	DBG("Ist1", stat, 0, 0);
+
+	/* DMA status */
+	scratch = stat & DMA_INTERRUPTS;
+	stat &= ~DMA_INTERRUPTS;
+	scratch >>= DMA_0_INTERRUPT;
+	for (num = 0; scratch; num++) {
+		struct usb3380_dma_regs	__iomem *dma;
+
+		tmp = 1 << num;
+		if ((tmp & scratch) == 0)
+			continue;
+		scratch ^= tmp;
+
+		ep = &dev->ep [num + 1];
+		dma = ep->dma;
+
+		if (!dma)
+			continue;
+
+		/* clear ep's dma status */
+		tmp = readl (&dma->dmastat);
+		writel (tmp, &dma->dmastat);
+
+		if ((tmp & (1 << DMA_TRANSACTION_DONE_INTERRUPT)) == 0) {
+			VLOG("None", stat, tmp, 0);
+			continue;
+		}
+
+		VLOG("Ddne", ep->num, tmp, 0);
+
+		scan_dma_completions (ep);
+
+		/* disable dma on inactive queues; else maybe restart */
+		if (list_empty (&ep->queue)) {
+			abort_dma(ep);
+		} else {
+			if (!dma_in_progress(ep))
+				restart_dma (ep);
+			else if (ep->is_in) {
+				struct usb3380_request	*req;
+				__le32			dmacount;
+				/* the descriptor at the head of the chain
+				 * may still have VALID_BIT clear; that's
+				 * used to trigger changing DMA_FIFO_VALIDATE
+				 * (affects automagic zlp writes).
+				 */
+				req = list_entry (ep->queue.next,
+						struct usb3380_request, queue);
+				dmacount = req->td->dmacount;
+				dmacount &= cpu_to_le32 (
+						(1 << VALID_BIT)
+						| DMA_TRANSFER_MAX_LENGTH);
+				VLOG("CVad", ep->num, dmacount, (u32)req->td_dma);
+				if (dmacount && (dmacount & valid_bit) == 0) {
+					restart_dma (ep);
+				}
+			}
+		}
+		ep->irqs++;
+	}
+
+	/* NOTE:  there are other PCI errors we might usefully notice.
+	 * if they appear very often, here's where to try recovering.
+	 */
+	if (stat & PCI_ERROR_INTERRUPTS) {
+		ERRMSG (dev, "pci dma error; stat %08x\n", stat);
+		stat &= ~PCI_ERROR_INTERRUPTS;
+		/* these are fatal errors, but "maybe" they won't
+		 * happen again ...
+		 */
+		stop_activity (dev, dev->driver);
+		ep0_start (dev);
+		stat = 0;
+	}
+
+	if (stat)
+		WARNING("Uis1", stat, 0, 0);
+}
+
+static irqreturn_t usb3380_intr (int irq, void *_dev)
+{
+	struct usb3380 *dev = _dev;
+
+	/* shared interrupt, not ours */
+	if (!(readl(&dev->regs->irqstat0) & (1 << INTA_ASSERTED)))
+		return IRQ_NONE;
+
+	spin_lock (&dev->lock);
+
+	/* handle disconnect, dma, and more */
+	handle_stat1_irqs (dev, readl (&dev->regs->irqstat1));
+
+	/* control requests and PIO */
+	handle_stat0_irqs (dev, readl (&dev->regs->irqstat0));
+
+	spin_unlock (&dev->lock);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************/
+
+static void usb3380_shutdown (struct pci_dev *pdev)
+{
+	struct usb3380 *dev = pci_get_drvdata(pdev);
+
+	/* disable IRQs */
+	writel (0, &dev->regs->pciirqenb0);
+	writel (0, &dev->regs->pciirqenb1);
+
+	/* disable the pullup so the host will think we're gone */
+	writel (0, &dev->usb->usbctl);
+}
+
+static void usb3380_remove (struct pci_dev *pdev)
+{
+	struct usb3380 *dev = pci_get_drvdata(pdev);
+
+#ifdef USB_GADGET_NAPI
+	usb_del_gadget_udc(&dev->gadget);
+#endif
+	BUG_ON(dev->driver);
+
+	usb3380_led_shutdown(dev);
+
+	/* recycle the allocated resources */
+	if (dev->requests) {
+		int i;
+		for (i = 1; i < 5; i++) {
+			if (!dev->ep [i].dummy)
+				continue;
+#ifndef INTERNAL_DESCRIPTOR
+			pci_pool_free (dev->requests, dev->ep [i].dummy,
+					dev->ep [i].td_dma);
+#endif
+		}
+		pci_pool_destroy (dev->requests);
+	}
+
+	if (dev->got_irq)
+		free_irq (pdev->irq, dev);
+	if (dev->regs)
+		iounmap (dev->regs);
+	if (dev->region)
+		release_mem_region (pci_resource_start (pdev, 0),
+				pci_resource_len (pdev, 0));
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+	if (dev->region_bar1)
+		release_mem_region (pci_resource_start (pdev, 1),
+				pci_resource_len (pdev, 1));
+#endif
+	if (dev->enabled)
+		pci_disable_device (pdev);
+
+	device_unregister (&dev->gadget.dev);
+	pci_set_drvdata (pdev, NULL);
+	usb3380_cleanup_debugfs(dev);
+	usb3380_cleanup_logger(dev);
+
+	INFOMSG(dev, "USB3380 driver unbound\n");
+
+	usb3380_controller = NULL;
+}
+
+static int __devinit usb3380_probe(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	struct usb3380	*dev;
+	unsigned long resource, len;
+	void __iomem *base;
+	int i, err = 0;
+	u32 Scratch, FsmValue;
+
+	/* one controller only */
+	if (usb3380_controller) {
+		printk(KERN_WARNING "already probed\n");
+		return -EBUSY;
+	}
+
+	if (!pdev->irq) {
+		printk(KERN_ERR "Check PCI %s IRQ setup!\n", pci_name(pdev));
+		return -ENODEV;
+	}
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (NULL == dev) {
+		printk(KERN_ERR "enomem %s\n", pci_name(pdev));
+		return -ENOMEM;
+	}
+
+	err = usb3380_init_logger(dev, log_entries);
+	if (err) goto done;
+
+	spin_lock_init (&dev->lock);
+
+	dev->pdev = pdev;
+	dev->gadget.ops = &usb3380_ops;		/* usb_gadget_ops */
+
+	/* the "gadget" abstracts/virtualizes the controller */
+	dev_set_name(&dev->gadget.dev, "gadget");
+	dev->gadget.dev.parent = &pdev->dev;
+	dev->gadget.dev.dma_mask = pdev->dev.dma_mask;
+	dev->gadget.dev.release = gadget_release;
+	dev->gadget.name = driver_name;
+
+	/* now all the pci goodies ... */
+	if (pci_enable_device (pdev) < 0) {
+		ERRMSG(dev, "can't enable\n");
+		err = -ENODEV;
+		goto done;
+	}
+	dev->enabled = 1;
+
+	resource = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	if (!request_mem_region(resource, len, driver_name)) {
+		ERRMSG(dev, "controller already in use\n");
+		err = -EBUSY;
+		goto done;
+	}
+	dev->region = 1;
+
+	base = ioremap_nocache(resource, len);
+	if (!base) {
+		ERRMSG(dev, "cannot ioremap MMIO base\n");
+		err = -EFAULT;
+		goto done;
+	}
+
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+	resource = pci_resource_start(pdev, 1);
+	len = pci_resource_len(pdev, 1);
+	if (!request_mem_region(resource, len, driver_name)) {
+		ERRMSG(dev, "cannot request memory region for BAR1\n");
+		err = -EBUSY;
+		goto done;
+	}
+	dev->region_bar1 = 1;
+
+	dev->pool_desc = ioremap_nocache(resource, len);
+	if (!dev->pool_desc) {
+		ERRMSG(dev, "cannot ioremap BAR1 iomem\n");
+		err = -EFAULT;
+		goto done;
+	}
+	/* if (desc-on-chip) virt(BAR1) == phys(0x4000) */
+	dev->pool_desc_dma = INTERNAL_DESCRIPTOR_OFFSET;
+#endif
+
+	dev->regs = (struct usb3380_regs __iomem *) base;
+	dev->usb = (struct usb3380_usb_regs __iomem *) (base + 0x0080);
+	dev->pci = (struct usb3380_pci_regs __iomem *) (base + 0x0100);
+	dev->dma = (struct usb3380_dma_regs __iomem *) (base + 0x0180);
+	dev->dmap = (struct usb3380_dmap_regs __iomem *) (base + 0x0680);
+	dev->dep = (struct usb3380_dep_regs __iomem *) (base + 0x0200);
+	dev->epcfg = (struct usb3380_ep_cfg __iomem *) (base + 0x0300);
+	dev->epregs = (struct usb3380_ep_regs __iomem *) (base + 0x0304);
+	dev->ffregs = (struct usb3380_fifo_regs __iomem *) (base + 0x0500);
+	dev->llregs = (struct usb3380_ll_regs __iomem *) (base + 0x0700);
+	dev->ll_tsn_regs = (struct usb3380_ll_tsn_regs __iomem *) (base + 0x077c);
+	dev->ll_chicken_reg = (struct usb3380_ll_chi_regs __iomem *) (base + 0x079c);
+	dev->plregs = (struct usb3380_pl_regs __iomem *) (base + 0x0800);
+
+	/* Enhanced or Legacy Mode? */
+	enhanced = (readl(&dev->usb->usbstat) & (1 << ENHANCED_MODE)) ? 1 : 0;
+	ep_count = (enhanced) ? NR_EPS_ENHANCE : NR_EPS_LEGCY;
+
+	pci_set_drvdata(pdev, dev);
+
+	Scratch = get_idx_reg (dev->regs, SCRATCH);
+	FsmValue = Scratch & (0xf << DEFECT7374_FSM_FIELD);
+
+	/* See if firmware needs to set up for workaround: */
+	if (FsmValue == DEFECT7374_FSM_SS_CONTROL_READ){
+		writel (0, &dev->usb->usbctl);
+	}
+
+	/* controller endpoints reinit */
+	usb_reset (dev);
+	usb_reinit (dev);
+
+	if (request_irq (pdev->irq, usb3380_intr, IRQF_SHARED, driver_name, dev)
+			!= 0) {
+		ERRMSG(dev, "request interrupt %d failed\n", pdev->irq);
+		err = -EBUSY;
+		goto done;
+	}
+	dev->got_irq = 1;
+
+	/* DMA setup */
+	dev->requests = pci_pool_create ("requests", pdev,
+		sizeof (struct usb3380_dma),
+		0 /* no alignment requirements */,
+		0 /* or page-crossing issues */);
+	if (!dev->requests) {
+		ERRMSG(dev, "can't get request data pool\n");
+		err = -ENOMEM;
+		goto done;
+	}
+
+	for (i = 1; i < 5; i++) {
+		struct usb3380_dma	*td;
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+		td = bar_pool_alloc(dev, &dev->ep[i].td_dma);
+#else
+		td = pci_pool_alloc (dev->requests, GFP_KERNEL,
+				&dev->ep [i].td_dma);
+#endif
+		if (!td) {
+			ERRMSG(dev, "can't get dummy %d\n", i);
+			err = -ENOMEM;
+			goto done;
+		}
+		td->dmacount = 0;
+		td->dmaaddr = cpu_to_le32 (DMA_ADDR_INVALID);
+		td->dmadesc = td->dmaaddr;
+		dev->ep [i].dummy = td;
+	}
+
+	pci_set_master (pdev);
+	pci_try_set_mwi (pdev);
+
+	dev->chiprev = get_idx_reg (dev->regs, IDXREG_CHIPREV) & 0xffff;
+	/* done */
+	INFOMSG(dev, "%s\n", driver_desc);
+	INFOMSG(dev, "irq %d, pci mem %p, chip rev %04x\n",
+			pdev->irq, base, dev->chiprev);
+	INFOMSG(dev, "Driver version: " DRIVER_VERSION "\n");
+	INFOMSG(dev, "Mode: %s Adapter Mode\n",
+			enhanced ? "Enhanced" : "Legacy");
+	INFOMSG(dev, "DMA %s\n", use_dma ? "enabled" : "disabled");
+
+	usb3380_controller = dev;
+
+	err = device_register (&dev->gadget.dev);
+	if (err) goto done;
+
+	usb3380_init_debugfs(dev);
+
+#ifdef USB_GADGET_NAPI
+	err = usb_add_gadget_udc(&pdev->dev, &dev->gadget);
+	if (err) goto done;
+#endif
+
+	return 0;
+
+done:
+	if (dev)
+		usb3380_remove(pdev);
+
+	return err;
+}
+
+/*****************************************************************************/
+
+static DEFINE_PCI_DEVICE_TABLE(usb3380_pci_tbl) = {
+	PLX_USB_CONTROLLER_DEVICE(0x2380),
+	PLX_USB_CONTROLLER_DEVICE(0x3380),
+	PLX_USB_CONTROLLER_DEVICE(0x3382),
+	/* required last entry */
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, usb3380_pci_tbl);
+
+static struct pci_driver usb3380_driver = {
+	.name     = (char *) driver_name,
+	.id_table = usb3380_pci_tbl,
+
+	.probe    = usb3380_probe,
+	.remove   = __devexit_p(usb3380_remove),
+	.shutdown = usb3380_shutdown,
+};
+
+MODULE_AUTHOR("PLX Technology");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+/**
+ * usb3380_init_module - Driver Registration Routine
+ **/
+
+static int __init usb3380_init_module(void)
+{
+	if (dma_outstanding_r > 7){
+		printk(KERN_ERR "The input dma_outstanding_r value %d is invalid, must be less than 8!!\n", dma_outstanding_r);
+		return -EINVAL;
+	}
+
+	if (dma_outstanding_w > 7){
+		printk(KERN_ERR "The input dma_outstanding_w value %d is invalid, must be less than 8!!\n", dma_outstanding_w);
+		return -EINVAL;
+	}
+	return pci_register_driver (&usb3380_driver);
+}
+
+module_init(usb3380_init_module);
+
+/**
+ * usb3380_exit_module - Driver Exit Cleanup Routine
+ **/
+
+static void __exit usb3380_exit_module(void)
+{
+	pci_unregister_driver (&usb3380_driver);
+}
+
+module_exit(usb3380_exit_module);
+
diff --git a/drivers/usb/gadget/usb3380.h b/drivers/usb/gadget/usb3380.h
new file mode 100644
index 0000000..175d458
--- /dev/null
+++ b/drivers/usb/gadget/usb3380.h
@@ -0,0 +1,319 @@
+
+#ifndef _USB3380_H_
+#define _USB3380_H_
+
+#include "usb3380_hw.h"
+
+#define PLX_USB_CONTROLLER_DEVICE(device_id) {	\
+	PCI_DEVICE(PCI_VENDOR_ID_PLX, device_id)}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)) || \
+	defined(CONFIG_USB_GADGET_SUPERSPEED)
+#define USB_GADGET_NAPI
+#endif
+
+#define USE_RDK_LEDS
+//#define USE_3380_FPGA
+#define USE_TUNE_LOOPHOST
+//#define INTERNAL_DESCRIPTOR
+/****************************************************************************/
+#define LOGFMT "%-4.4s  %8.8x  %8.8x  %8.8x  "
+
+typedef enum {
+	LOG_ERR,
+	LOG_WARN,
+	LOG_INFO,
+	LOG_DEBUG,
+	LOG_VERBOSE,
+} log_level_t;
+
+typedef struct _log_entry {
+	u32 text;
+	u32 arg1;
+	u32 arg2;
+	u32 arg3;
+} log_entry_t;
+
+struct logger {
+	log_entry_t *queue;
+	unsigned int entries;
+	unsigned int rdptr, wrptr;
+};
+
+#define ERROR(text, arg1, arg2, arg3)	\
+	__dbglog(LOG_ERR, text, arg1, arg2, arg3)
+
+#define WARNING(text, arg1, arg2, arg3)	\
+	__dbglog(LOG_WARN, text, arg1, arg2, arg3)
+
+#define INFO(text, arg1, arg2, arg3)	\
+	__dbglog(LOG_INFO, text, arg1, arg2, arg3)
+
+#define DBG(text, arg1, arg2, arg3)	\
+	__dbglog(LOG_DEBUG, text, arg1, arg2, arg3)
+
+#define VLOG(text, arg1, arg2, arg3)	\
+	__dbglog(LOG_VERBOSE, text, arg1, arg2, arg3)
+
+#define xprintk(level, dev, fmt, args ...)	\
+		printk(level "%s %s: "	fmt, \
+				driver_name, pci_name(dev->pdev), ## args)
+
+#define DBGMSG(dev, fmt, args ...)	\
+	xprintk(KERN_DEBUG, dev, fmt, ## args)
+#define INFOMSG(dev, fmt, args ...)	\
+	xprintk(KERN_INFO, dev, fmt, ## args)
+#define ERRMSG(dev, fmt, args ...)	\
+	xprintk(KERN_ERR, dev, fmt, ## args)
+/*****************************************************************************/
+
+struct usb3380_dma {
+	__le32		dmacount;
+	__le32		dmaaddr;		/* the buffer */
+	__le32		dmadesc;		/* next dma descriptor */
+	__le32		_reserved;
+} __attribute__ ((aligned (16)));
+
+struct usb3380_ep {
+	struct usb_ep				ep;
+	struct usb3380_ep_cfg		__iomem *cfg;
+	struct usb3380_ep_regs		__iomem *regs;
+	struct usb3380_fifo_regs    __iomem *ffregs;
+	struct usb3380_dma_regs		__iomem *dma;
+	struct usb3380_dmap_regs	__iomem *dmap;
+	struct usb3380_dma			*dummy;
+	dma_addr_t					td_dma;	/* of dummy */
+	struct usb3380				*dev;
+	unsigned long				irqs;
+
+	/* analogous to a host-side qh */
+	struct list_head			queue;
+	const struct usb_endpoint_descriptor	*desc;
+	unsigned			num : 8,
+						fifo_size : 16,
+						in_fifo_validate : 1,
+						out_overflow : 1,
+						stopped : 1,
+						wedged : 1,
+						is_in : 1,
+						is_iso : 1,
+						in_zlp : 1,
+						responded : 1;
+	unsigned			is_halt : 1,
+						dma_started : 1;
+};
+
+struct usb3380_request {
+	struct usb_request		req;
+	struct usb3380_dma		*td;
+	dma_addr_t			td_dma;
+	struct list_head		queue;
+	unsigned			mapped : 1,
+					valid : 1;
+};
+
+struct usb3380_dep_regs {
+	/* offset 0x0200, 0x0210, 0x220, 0x230, 0x240, 0x250 */
+	u32     dep_cfg;
+	/* offset 0x0204, 0x0214, 0x224, 0x234, 0x244, 0x254 */
+	u32     dep_rsp;
+	u32     _unused[2];
+} __attribute__ ((packed));
+
+struct usb3380 {
+	/* each pci device provides one gadget, several endpoints */
+	struct usb_gadget			gadget;
+	spinlock_t					lock;
+	struct usb3380_ep			ep[9];
+	struct usb_gadget_driver 	*driver;
+	unsigned		enabled : 1,
+					protocol_stall : 1,
+					softconnect : 1,
+					got_irq : 1,
+					region : 1,
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+					region_bar1 : 1,
+#endif
+					u1_enable: 1,
+					u2_enable: 1,
+					ltm_enable: 1,
+					wakeup_enable: 1,
+					selfpowered: 1,
+					addressed_state: 1;
+	u16				chiprev;
+
+	/* pci state used to access those endpoints */
+	struct pci_dev			*pdev;
+	struct usb3380_regs			__iomem *regs;
+	struct usb3380_usb_regs		__iomem *usb;
+	struct usb3380_pci_regs		__iomem *pci;
+	struct usb3380_dma_regs		__iomem *dma;
+	struct usb3380_dmap_regs	__iomem *dmap;
+	struct usb3380_dep_regs		__iomem *dep;
+	struct usb3380_ep_cfg		__iomem *epcfg;
+	struct usb3380_ep_regs		__iomem *epregs;
+	struct usb3380_fifo_regs	__iomem *ffregs;
+	struct usb3380_ll_regs		__iomem *llregs;
+	struct usb3380_ll_tsn_regs	__iomem *ll_tsn_regs;
+	struct usb3380_ll_chi_regs      __iomem *ll_chicken_reg;
+	struct usb3380_pl_regs		__iomem *plregs;
+
+	struct pci_pool			*requests;
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
+	struct dentry               *debugfs_root;
+#endif
+	struct logger               logger;
+#if defined(USE_TUNE_LOOPHOST) && defined(INTERNAL_DESCRIPTOR)
+	void __iomem *pool_desc;
+	dma_addr_t pool_desc_dma;
+#endif
+};
+
+#ifdef USE_RDK_LEDS
+static inline void usb3380_led_init (struct usb3380 *dev)
+{
+	writel ((1 << GPIO3_LED_SELECT)
+		| (1 << GPIO3_OUTPUT_ENABLE)
+		| (1 << GPIO2_OUTPUT_ENABLE)
+		| (1 << GPIO1_OUTPUT_ENABLE)
+		| (1 << GPIO0_OUTPUT_ENABLE)
+		, &dev->regs->gpioctrl);
+}
+
+/* indicate speed with bi-color LED 0/1 */
+static inline
+void usb3380_led_speed (struct usb3380 *dev, enum usb_device_speed speed)
+{
+	u32	val = readl (&dev->regs->gpioctrl);
+	switch (speed) {
+	case USB_SPEED_HIGH:		/* green */
+		val &= ~(1 << GPIO0_DATA);
+		val |= (1 << GPIO1_DATA);
+		break;
+	case USB_SPEED_FULL:		/* red */
+		val &= ~(1 << GPIO1_DATA);
+		val |= (1 << GPIO0_DATA);
+		break;
+	case USB_SPEED_SUPER:
+		val |= (1 << GPIO0_DATA);
+		val |= (1 << GPIO1_DATA);
+		break;
+	default:			/* (off/black) */
+		val &= ~((1 << GPIO1_DATA) | (1 << GPIO0_DATA));
+		break;
+	}
+	writel (val, &dev->regs->gpioctrl);
+}
+
+/* indicate power with LED 2 */
+static inline void usb3380_led_active (struct usb3380 *dev, int is_active)
+{
+	u32	val = readl (&dev->regs->gpioctrl);
+
+	// FIXME this LED never seems to turn on.
+	if (is_active)
+		val |= GPIO2_DATA;
+	else
+		val &= ~GPIO2_DATA;
+	writel (val, &dev->regs->gpioctrl);
+}
+
+static inline void usb3380_led_shutdown (struct usb3380 *dev)
+{
+	/* turn off all four GPIO*_DATA bits */
+	writel (readl (&dev->regs->gpioctrl) & ~0x0f,
+			&dev->regs->gpioctrl);
+}
+#else /* USE_RDK_LEDS */
+
+#define usb3380_led_init(dev)		do { } while (0)
+#define usb3380_led_speed(dev, speed)	do { } while (0)
+#define usb3380_led_shutdown(dev)	do { } while (0)
+
+#endif
+
+static inline void allow_status (struct usb3380_ep *ep)
+{
+	/* ep0 only */
+#if 0
+	writel ((1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE) |
+			(1 << CLEAR_NAK_PACKETS) |
+			(1 << CLEAR_NAK_OUT_PACKETS_MODE)
+			, &ep->regs->ep_rsp);
+#endif
+	/* Control Status Phase Handshake was set by the chip when the setup
+	 * packet arrived. While set, the chip automatically NAKs the host's
+	 * Status Phase tokens.
+	 */
+	writel (1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE, &ep->regs->ep_rsp);
+	ep->stopped = 1;
+
+	/* TD 9.9 Halt Endpoint test.  TD 9.22 set feature test. */
+	ep->responded = 0;
+}
+
+static inline void start_out_naking (struct usb3380_ep *ep)
+{
+	writel ((1 << SET_NAK_PACKETS), &ep->regs->ep_rsp);
+}
+
+static inline void stop_out_naking (struct usb3380_ep *ep)
+{
+	writel ((1 << NAK_PACKETS), &ep->regs->ep_stat);
+}
+
+/* count (<= 4) bytes in the next fifo write will be valid */
+static inline void set_fifo_bytecount (struct usb3380_ep *ep, unsigned count)
+{
+	u32 tmp = readl(&ep->cfg->ep_cfg) & (~(0x07 << EP_FIFO_BYTE_COUNT));
+	writel (tmp | (count << EP_FIFO_BYTE_COUNT), &ep->cfg->ep_cfg);
+}
+
+static inline void ep_stall (struct usb3380_ep *ep, int stall)
+{
+	u32 PlEpCtrl, EndpointSelect;
+	struct usb3380 *dev = ep->dev;
+
+	if (stall) {
+		writel ((1 << SET_ENDPOINT_HALT) |
+				//(1 << SET_NAK_PACKETS) |
+				(1 << CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE)
+				, &ep->regs->ep_rsp);
+		ep->is_halt = 1;
+	} else {
+		/* Workaround for SS SeqNum not cleared via Endpoint Halt (Clear) bit.*/
+		PlEpCtrl = readl(&dev->plregs->pl_ep_ctrl);
+		PlEpCtrl &= ~(0x001f<<ENDPOINT_SELECT);
+
+		/* Calculate endpoint number. */
+		
+		if (((readl(&dev->usb->usbstat) & (1 << ENHANCED_MODE)) ? 1 : 0)) {
+			/*Enhanced mode*/
+			if (ep->num > 4)
+				EndpointSelect = (((ep->num) % 2 != 0) ? ((ep->num - 4)*2) : ((ep->num - 4) * 2 + 1));
+			else
+				EndpointSelect = ((ep->num) % 2 + (ep->num) * 2);
+		} else
+			/* Legacy mode */
+			EndpointSelect = ((ep->num) % 2 + (ep->num) * 2);
+
+		PlEpCtrl |= (EndpointSelect << ENDPOINT_SELECT);
+
+		writel ((PlEpCtrl | (1 << SEQUENCE_NUMBER_RESET)), &dev->plregs->pl_ep_ctrl);
+
+		writel ((1 << CLEAR_ENDPOINT_HALT)
+				//| (1 << CLEAR_NAK_PACKETS)
+				| (1 << CLEAR_ENDPOINT_TOGGLE)
+				, &ep->regs->ep_rsp);
+		ep->is_halt = 0;
+	}
+}
+
+static inline int dma_in_progress(struct usb3380_ep *ep)
+{
+	return ep->dma_started && (readl (&ep->dma->dmactl) & (1 << DMA_ENABLE));
+}
+
+#endif
+
diff --git a/drivers/usb/gadget/usb3380_hw.h b/drivers/usb/gadget/usb3380_hw.h
new file mode 100644
index 0000000..9272dc6
--- /dev/null
+++ b/drivers/usb/gadget/usb3380_hw.h
@@ -0,0 +1,643 @@
+
+#ifndef _USB3380_HW_H_
+#define _USB3380_HW_H_
+
+/* PCI Configuration Register Map */
+#define REG_DEVICE_STATUS_AND_CONTROL                       0x70
+#define     MAX_PAYLOAD_SIZE                            5   /* 7:5 */
+#define         MAX_PAYLOAD_128                         0   /* 000b */
+#define         MAX_PAYLOAD_256                         1   /* 001b */
+#define     MAX_READ_REQUEST_SIZE                       12  /* 14:12 */
+#define         MAX_READ_REQUEST_512                    2   /* 010b */
+#define         MAX_READ_REQUEST_1024                   3   /* 011b */
+#define         MAX_READ_REQUEST_2048                   4   /* 100b */
+#define         MAX_READ_REQUEST_4096                   5   /* 101b */
+
+/* main registers, BAR0 + 0x0000 */
+struct usb3380_regs {
+	/* offset 0x0000 */
+	u32		devinit;
+#define     LOCAL_CLOCK_FREQUENCY                       8	/* 11:8 */
+#define     FORCE_PCI_RESET                             7
+#define     PCI_ID                                      6
+#define     PCI_ENABLE                                  5
+#define     FIFO_SOFT_RESET                             4
+#define     CFG_SOFT_RESET                              3
+#define     PCI_SOFT_RESET                              2
+#define     USB_SOFT_RESET                              1
+#define     M8051_RESET                                 0
+	u32		eectl;
+	u32		eeclkfreq;
+	u32		_unused0;
+	/* offset 0x0010 */
+	u32		pciirqenb0;	/* PCIE Interrupt Request Enable 0 */
+#define     GPEP3_IN_PCIE_INTERRUPT                             20
+#define     GPEP2_IN_PCIE_INTERRUPT                             19
+#define     GPEP1_IN_PCIE_INTERRUPT                             18
+#define     GPEP0_IN_PCIE_INTERRUPT                             17
+#define     USB_IN_FIFO_TIMEOUT_PCIE_INTERRUPT_ENABLE           11
+#define     USB_CFG_RETRY_PCIE_INTERRUPT_ENABLE                 10
+#define     USB2PCIE_TLP_DRAINED_PORT_1_PCIE_INTERRUPT_ENABLE   9
+#define     USB2PCIE_TLP_DRAINED_PORT_0_PCIE_INTERRUPT_ENABLE   8
+#define     SETUP_PACKET_PCIE_INTERRUPT_ENABLE                  7
+#define     GPEP3_OUT_PCIE_INTERRUPT_ENABLE                     4
+#define     GPEP2_OUT_PCIE_INTERRUPT_ENABLE                     3
+#define     GPEP1_OUT_PCIE_INTERRUPT_ENABLE                     2
+#define     GPEP0_OUT_PCIE_INTERRUPT_ENABLE                     1
+#define     ENDPOINT_0_PCIE_INTERRUPT_ENABLE                    0
+	u32		pciirqenb1;	/* PCIE Interrupt Request Enable 1 */
+#define     GLOBAL_PCIE_INTERRUPT                               31
+#define     PCIE_ENDPOINT_POWER_MGMT_PCIE_INTERRUPT_ENABLE      30
+#define     PCIE_HOT_RESET_PCIE_INTERRUPT_ENABLE                29
+#define     PCIE_DL_DOWN_STATE_CHANGE_PCIE_INTERRUPT_ENABLE     28
+#define     POWER_STATE_CHANGE_PCIE_INTERRUPT_ENABLE            27
+#define     PCI_PARITY_ERROR_PCIE_INTERRUPT_ENABLE              25
+#define     PCI_MASTER_ABORT_RECEIVED_PCIE_INTERRUPT_ENABLE     20
+#define     PCI_TARGET_ABORT_RECEIVED_PCIE_INTERRUPT_ENABLE     19
+#define     PCIE_HOT_PLUG_PCIE_INTERRUPT_ENABLE                 18
+#define     PCI_MASTER_CYCLE_DONE_PCIE_INTERRUPT_ENABLE         16
+#define     SOF_DOWNCOUNT_PCIE_INTERRUPT_ENABLE                 14
+#define     GPIO_PCIE_INTERRUPT_ENABLE                          13
+#define     DMA_3_PCIE_INTERRUPT_ENABLE                         12
+#define     DMA_2_PCIE_INTERRUPT_ENABLE                         11
+#define     DMA_1_PCIE_INTERRUPT_ENABLE                         10
+#define     DMA_0_PCIE_INTERRUPT_ENABLE                         9
+#define     EEPROM_DONE_PCIE_INTERRUPT_ENABLE                   8
+#define     VBUS_PCIE_INTERRUPT_ENABLE                          7
+#define     CONTROL_STATUS_PCIE_INTERRUPT_ENABLE                6
+#define     ROOT_PORT_RESET_PCIE_INTERRUPT_ENABLE               4
+#define     SUSPEND_REQUEST_PCIE_INTERRUPT_ENABLE               3
+#define     SUSPEND_REQUEST_CHANGE_PCIE_INTERRUPT_ENABLE        2
+#define     RESUME_PCIE_INTERRUPT_ENABLE                        1
+#define     SOF_PCIE_INTERRUPT_ENABLE                           0
+	u32		cpuirqenb0;		/* 8051 Interrupt Request Enable 0 */
+#define     GPEP3_IN_8051_INTERRUPT_ENABLE                      20
+#define     GPEP2_IN_8051_INTERRUPT_ENABLE                      19
+#define     GPEP1_IN_8051_INTERRUPT_ENABLE                      18
+#define     GPEP0_IN_8051_INTERRUPT_ENABLE                      17
+#define     USB_IN_FIFO_TIMEOUT_8051_INTERRUPT_ENABLE           11
+#define     USB_CFG_RETRY_8051_INTERRUPT_ENABLE                 10
+#define     USB2PCIE_TLP_DRAINED_PORT_1_8051_INTERRUPT_ENABLE   9
+#define     USB2PCIE_TLP_DRAINED_PORT_0_8051_INTERRUPT_ENABLE   8
+#define     SETUP_PACKET_8051_INTERRUPT_ENABLE                  7
+#define     GPEP3_OUT_8051_INTERRUPT_ENABLE                     4
+#define     GPEP2_OUT_8051_INTERRUPT_ENABLE                     3
+#define     GPEP1_OUT_8051_INTERRUPT_ENABLE                     2
+#define     GPEP0_OUT_8051_INTERRUPT_ENABLE                     1
+#define     ENDPOINT_0_8051_INTERRUPT_ENABLE                    0
+	u32		cpuirqenb1;
+#define     GLOBAL_8051_INTERRUPT_ENABLE                        31
+#define     PCIE_ENDPOINT_POWER_MGMT_8051_INTERRUPT_ENABLE      30
+#define     PCIE_HOT_RESET_8051_INTERRUPT_ENABLE                29
+#define     PCIE_DL_DOWN_STATE_CHANGE_8051_INTERRUPT_ENABLE     28
+#define     POWER_STATE_CHANGE_8051_INTERRUPT_ENABLE            27
+#define     PCI_PARITY_ERROR_8051_INTERRUPT_ENABLE              25
+#define     PCI_INTA_8051_INTERRUPT_ENABLE                      24
+#define     PCI_MASTER_ABORT_RECEIVED_8051_INTERRUPT_ENABLE     20
+#define     PCI_TARGET_ABORT_RECEIVED_8051_INTERRUPT_ENABLE     19
+#define     PCIE_HOT_PLUG_8051_INTERRUPT_ENABLE                 18
+#define     PCI_MASTER_CYCLE_DONE_8051_INTERRUPT_ENABLE         16
+#define     SOF_DOWNCOUNT_8051_INTERRUPT_ENABLE                 14
+#define     GPIO_8051_INTERRUPT_ENABLE                          13
+#define     DMA_3_8051_INTERRUPT_ENABLE                         12
+#define     DMA_2_8051_INTERRUPT_ENABLE                         11
+#define     DMA_1_8051_INTERRUPT_ENABLE                         10
+#define     DMA_0_8051_INTERRUPT_ENABLE                         9
+#define     SERIAL_EEPROM_DONE_8051_INTERRUPT_ENABLE            8
+#define     VBUS_8051_INTERRUPT_ENABLE                          7
+#define     CONTROL_STATUS_8051_INTERRUPT_ENABLE                6
+#define     ROOT_PORT_RESET_8051_INTERRUPT_ENABLE               4
+#define     SUSPEND_REQUEST_8051_INTERRUPT_ENABLE               3
+#define     SUSPEND_REQUEST_CHANGE_8051_INTERRUPT_ENABLE        2
+#define     RESUME_8051_INTERRUPT_ENABLE                        1
+#define     SOF_8051_INTERRUPT_ENABLE                           0
+	/* offset 0x0020 */
+	u32		usbirqenb0;	/* Used only by firmware running on the 8051 */
+	u32		usbirqenb1; /* Reserved in Legacy Adapter mode */
+	u32		irqstat0;
+	/* GPEP[0..3]_IN_PCIE_INTERRUPT_STATUS - Enahnced Mode only */
+#define     GPEP3_IN_PCIE_INTERRUPT_STATUS                      20
+#define     GPEP2_IN_PCIE_INTERRUPT_STATUS                      19
+#define     GPEP1_IN_PCIE_INTERRUPT_STATUS                      18
+#define     GPEP0_IN_PCIE_INTERRUPT_STATUS                      17
+#define     INTA_ASSERTED                                       12
+#define     USB_IN_FIFO_TIMEOUT_INTERRUPT_STATUS                11
+#define     USB_CFG_RETRY_INTERRUPT_STATUS                      10
+#define     USB2PCIE_TLP_DRAINED_PORT_1_STATUS                  9
+#define     USB2PCIE_TLP_DRAINED_PORT_0_STATUS                  8
+#define     SETUP_PACKET_INTERRUPT_STATUS                       7
+#define     GPEP3_OUT_PCIE_INTERRUPT_STATUS                     4
+#define     GPEP2_OUT_PCIE_INTERRUPT_STATUS                     3
+#define     GPEP1_OUT_PCIE_INTERRUPT_STATUS                     2
+#define     GPEP0_OUT_PCIE_INTERRUPT_STATUS                     1
+#define     ENDPOINT_0_INTERRUPT_STATUS                         0
+	u32		irqstat1;
+#define     PCIE_ENDPOINT_POWER_MGMT_INTERRUPT                  30
+#define     PCIE_HOT_RESET_INTERRUPT                            29
+#define     PCIE_DL_DOWN_STATE_CHANGE_INTERRUPT                 28
+#define     POWER_STATE_CHANGE_INTERRUPT                        27
+#define     PCI_PARITY_ERROR_INTERRUPT                          25
+#define     PCI_INTA_INTERRUPT                                  24
+#define     PCI_MASTER_ABORT_RECEIVED_INTERRUPT                 20
+#define     PCI_TARGET_ABORT_RECEIVED_INTERRUPT                 19
+#define     PCIE_HOT_PLUG_INTERRUPT                             18
+#define     PCI_MASTER_CYCLE_DONE_INTERRUPT                     16
+#define     SOF_DOWNCOUNT_INTERRUPT                             14
+#define     GPIO_INTERRUPT                                      13
+#define     DMA_3_INTERRUPT                                     12
+#define     DMA_2_INTERRUPT                                     11
+#define     DMA_1_INTERRUPT                                     10
+#define     DMA_0_INTERRUPT                                     9
+#define     SERIAL_EEPROM_DONE_INTERRUPT                        8
+#define     VBUS_INTERRUPT                                      7
+#define     CONTROL_STATUS_INTERRUPT                            6
+#define     ROOT_PORT_RESET_INTERRUPT                           4
+#define     SUSPEND_REQUEST_INTERRUPT                           3
+#define     SUSPEND_REQUEST_CHANGE_INTERRUPT                    2
+#define     RESUME_INTERRUPT                                    1
+#define     SOF_INTERRUPT                                       0
+	/* Index Access Registers: offset 0x0030 */
+	u32		idxaddr;
+#define     IDXREG_DIAG            0x00
+#define     IDXREG_PKTLEN          0x01
+#define     IDXREG_FRAME           0x02
+#define     IDXREG_CHIPREV         0x03
+#define     IDXREG_UFRAME          0x04
+#define     IDXREG_FRAME_COUNT     0x05
+#define     IDXREG_HS_MAXPOWER     0x06
+#define     IDXREG_FS_MAXPOWER     0x07
+#define     IDXREG_HS_INTPOLL_RATE 0x08
+#define     IDXREG_FS_INTPOLL_RATE 0x09
+#define     HS_NAK_RATE            0x0a
+#define     SCRATCH                0x0b
+	/* Index 0ch - 1fh: Reserved */
+	/* Index 20h + n * 10h: GPEP[3:0/Out/In]_HS_MAXPKT */
+	u32		idxdata;
+	u32		fifoctl;
+#define     EP_ABCD_1K             0
+#define     EP_AB_2K               1
+#define     EP_A_2K_BC_1K          2
+	u32		bar2ctl;
+    u32		bar3ctl;
+	u32		_unused2[3];	/* 0x0044-0x004c */
+	/* offset 0x0050 */
+	u32		gpioctrl;
+#define     GPIO3_PWM_ENABLE                                    27
+#define     GPIO2_PWM_ENABLE                                    26
+#define     GPIO1_PWM_ENABLE                                    25
+#define     GPIO0_PWM_ENABLE                                    24
+#define     GPIO3_INPUT_DEBOUNCE_ENABLE                         19
+#define     GPIO2_INPUT_DEBOUNCE_ENABLE                         18
+#define     GPIO1_INPUT_DEBOUNCE_ENABLE                         17
+#define     GPIO0_INPUT_DEBOUNCE_ENABLE                         16
+#define     GPIO3_LED_SELECT                                    12
+#define     GPIO3_INTERRUPT_ENABLE                              11
+#define     GPIO2_INTERRUPT_ENABLE                              10
+#define     GPIO1_INTERRUPT_ENABLE                              9
+#define     GPIO0_INTERRUPT_ENABLE                              8
+#define     GPIO3_OUTPUT_ENABLE                                 7
+#define     GPIO2_OUTPUT_ENABLE                                 6
+#define     GPIO1_OUTPUT_ENABLE                                 5
+#define     GPIO0_OUTPUT_ENABLE                                 4
+#define     GPIO3_DATA                                          3
+#define     GPIO2_DATA                                          2
+#define     GPIO1_DATA                                          1
+#define     GPIO0_DATA                                          0
+	u32		gpiostat;
+#define     GPIO3_INTERRUPT                                     3
+#define     GPIO2_INTERRUPT                                     2
+#define     GPIO1_INTERRUPT                                     1
+#define     GPIO0_INTERRUPT                                     0
+} __attribute__ ((packed));
+
+/* usb control, BAR0 + 0x0080 */
+struct usb3380_usb_regs {
+	/* offset 0x0080 */
+	u32		stdrsp;
+#define     STALL_UNSUPPORTED_REQUESTS                          31
+#define     SET_ISOCHRONOUS_DELAY                               24
+#define     GET_STRING_DESCRIPTOR_3                             23
+#define     SET_SEL                                             22
+#define     GET_BOS_DESCRIPTOR                                  21
+#define     SET_CLR_LTM_ENABLE                                  20
+#define     SET_CLR_U2_ENABLE                                   19
+#define     SET_CLR_U1_ENABLE                                   18
+#define     SET_CLR_FUNCTION_SUSPEND                            17
+#define     SET_TEST_MODE                                       16
+#define     GET_OTHER_SPEED_CFG                                 15
+#define     GET_DEVICE_QUALIFIER                                14
+#define     SET_ADDRESS                                         13
+#define     ENDPOINT_SET_CLEAR_HALT                             12
+#define     DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP               11
+#define     GET_STRING_DESCRIPTOR_2                             10
+#define     GET_STRING_DESCRIPTOR_1                             9
+#define     GET_STRING_DESCRIPTOR_0                             8
+#define     GET_SET_INTERFACE                                   6
+#define     GET_SET_CFG                                         5
+#define     GET_CFG_DESCRIPTOR                                  4
+#define     GET_DEVICE_DESCRIPTOR                               3
+#define     GET_ENDPOINT_STATUS                                 2
+#define     GET_INTERFACE_STATUS                                1
+#define     GET_DEVICE_STATUS                                   0
+	u32		prodvendid;
+#define     PRODUCT_ID                                          16
+#define     VENDOR_ID                                           0
+	u32		relnum;
+#define     DEVICE_RELEASE_NUMBER                               0
+	u32		usbctl;
+#define     PRODUCT_ID_STRING_ENABLE                            13
+#define     VENDOR_ID_STRING_ENABLE                             12
+#define     USB_ROOT_PORT_WAKEUP_ENABLE                         11
+#define     VBUS_PIN                                            10
+#define     TIMED_DISCONNECT                                    9
+#define     IMMEDIATELY_SUSPEND                                 7
+#define     SELF_POWERED_USB_DEVICE                             6
+#define     REMOTE_WAKEUP_SUPPORT                               5
+#define     PME_POLARITY                                        4
+#define     USB_DETECT_ENABLE                                   3
+#define     PCIE_WAKEUP_ENABLE                                  2
+#define     REMOTE_WAKEUP_ENABLE                                1
+#define     SELF_POWERED_STATUS                                 0
+	/* offset 0x0090 */
+	u32		usbstat;
+#define     HOST_MODE                                           12
+#define     ENHANCED_MODE                                       11
+#define     REMOTE_WAKEUP_STATUS                                10
+#define     SUSPEND_STATUS                                      9
+#define     SUPER_SPEED_MODE                                    8
+#define     HIGH_SPEED_MODE                                     7
+#define     FULL_SPEED_MODE                                     6
+#define     GENERATE_RESUME                                     5
+#define     GENERATE_DEVICE_REMOTE_WAKEUP                       4
+	u32		xcvrdiag;
+#define     FORCE_HIGH_SPEED_MODE                               31
+#define     FORCE_FULL_SPEED_MODE                               30
+#define     USB_TEST_MODE                                       24	/* 26:24 */
+#define     LINE_STATE                                          16	/* 17:16 */
+#define     TRANSCEIVER_OPERATION_MODE                          2	/* 3:2 */
+#define     TRANSCEIVER_SELECT                                  1
+#define     TERMINATION_SELECT                                  0
+	u32		setupdw0;
+	u32		setupdw1;
+	/* offset 0x00A0 */
+	u32		_unused0;
+	u32		ouraddr;
+#define     FORCE_IMMEDIATE                                     7
+#define     OUR_USB_ADDRESS                                     0	/* 6:0 */
+	u32		ourconfig;
+	u32		_unused1[2];
+	/* offset 0x00B4 */
+	u32     usbclass;
+#define     DEVICE_PROTOCOL                     16	/* 23:16 */
+#define     DEVICE_SUB_CLASS                    8	/* 15:8 */
+#define     DEVICE_CLASS                        0	/* 7:0 */
+	u32		ss_sel;
+#define		U2_SYSTEM_EXIT_LATENCY				8	/* 23:8 */
+#define		U1_SYSTEM_EXIT_LATENCY				0	/* 7:0 */
+	u32		ss_del;
+#define		U2_DEVICE_EXIT_LATENCY				8	/* 23:8 */
+#define		U1_DEVICE_EXIT_LATENCY				0	/* 7:0 */
+	u32		usb2lpm;
+#define		USB_L1_LPM_HIRD                     2	/* 5:2 */
+#define		USB_L1_LPM_REMOTE_WAKE              1
+#define		USB_L1_LPM_SUPPORT                  0
+	u32		usb3belt;
+#define		BELT_MULTIPLIER					    10	/* 11:10 */
+#define		BEST_EFFORT_LATENCY_TOLERANCE		0	/* 9:0 */
+	u32		usbctl2;
+#define		LTM_ENABLE                          7
+#define		U2_ENABLE                           6
+#define		U1_ENABLE                           5
+#define		FUNCTION_SUSPEND                    4
+#define		USB3_CORE_ENABLE                    3
+#define		USB2_CORE_ENABLE                    2
+#define		SERIAL_NUMBER_STRING_ENABLE         0
+	u32		in_timeout;
+#define		GPEP3_TIMEOUT					19
+#define		GPEP2_TIMEOUT					18
+#define		GPEP1_TIMEOUT					17
+#define		GPEP0_TIMEOUT					16
+#define		GPEP3_TIMEOUT_VALUE				13	/* 15:13 */
+#define		GPEP3_TIMEOUT_ENABLE			12
+#define		GPEP2_TIMEOUT_VALUE				9	/* 11:9 */
+#define		GPEP2_TIMEOUT_ENABLE			8
+#define		GPEP1_TIMEOUT_VALUE				5	/* 7:5 */
+#define		GPEP1_TIMEOUT_ENABLE			4
+#define		GPEP0_TIMEOUT_VALUE				1	/* 3:1 */
+#define		GPEP0_TIMEOUT_ENABLE			0
+	u32		isodelay;
+#define		ISOCHRONOUS_DELAY				0
+} __attribute__ ((packed));
+
+/* pci control, BAR0 + 0x0100 */
+struct usb3380_pci_regs {
+	/* offset 0x0100 */
+	u32		 pcimstctl;
+#define		PCIE_DW_LENGTH					24	/* 30:24 */
+#define		PCIE_PORT						20
+#define		MESSAGE_TYPE					19
+#define		MESSAGE_ROUTING					16	/* 18:16 */
+#define		MESSAGE_CODE					8	/* 15:8 */
+#define		PCIE_MASTER_READ_WRITE			7
+#define		PCIE_MASTER_START				6
+#define		PCIE_MASTER_COMMAND_SELECT		4	/* 5:4 */
+#define		PCIE_FIRST_BYTE_ENABLES			0	/* 3:0 */
+	u32		 pcimstaddr;
+	u32		 pcimstdata;
+	u32		 pcimststat;
+#define     ROOT_COMPLEX_MODE               0
+	u32		csrctl;
+#define		CSR_ADDRESS                     16	/* 31:16 */
+#define		CSR_READ_WRITE                  7
+#define		CSR_START                       6
+#define		CSR_SPACE_SELECT                4	/* 5:4 */
+#define		CSR_BYTE_ENABLES                0	/* 3:0 */
+	u32		csrdata;
+#define		CSR_DATA                        0	/* 31:0 */
+	u32		semaphore;
+#define		CSR_SEMAPHORE					0
+	u32		pcimstmsg;
+#define		PCI_MASTER_MSG					0	/* 31:0 */
+} __attribute__ ((packed));
+
+/* dma control, BAR0 + 0x0180 */
+struct usb3380_dma_regs {
+	/* offset 0x0180, 0x01a0, 0x01c0, 0x01e0, */
+	u32		dmactl;
+#define     DMA_ABORT_DONE_INTERRUPT_ENABLE                     27
+#define     DMA_PAUSE_DONE_INTERRUPT_ENABLE                     26
+#define     DMA_DESCRIPTOR_DONE_INTERRUPT_ENABLE                25
+#define     PAUSE_MODE                                          23
+#define     PREFETCH_DISABLE                                    22
+#define     DMA_CLEAR_COUNT_ENABLE                              21
+#define     DESCRIPTOR_POLLING_RATE                             19	/* 20:19 */
+#define         POLL_CONTINUOUS                                 0
+#define         POLL_1_USEC                                     1
+#define         POLL_100_USEC                                   2
+#define         POLL_1_MSEC                                     3
+#define     DMA_VALID_BIT_POLLING_ENABLE                        18
+#define     DMA_VALID_BIT_ENABLE                                17
+#define     DMA_DESCRIPTOR_MODE                                 16
+#define     DMA_REQUEST_OUTSTANDING                             5	/* 7:5 */
+#define     DMA_OUT_AUTO_START_ENABLE                           4
+#define     DMA_FIFO_VALIDATE                                   2
+#define     DMA_ENABLE                                          1
+#define     DMA_ADDRESS_CONSTANT                                0
+	/* offset 0x184, 0x1a4, 0x1c4, 0x1e4 */
+	u32		dmastat;
+#define     DMA_COMPLETION_SEQUENCE_ERROR_STATUS                31
+#define     DMA_ABORT_DONE_INTERRUPT                            27
+#define     DMA_PAUSE_DONE_INTERRUPT                            26
+#define     DMA_LAST_DESCRIPTOR_DONE_INTERRUPT                  25
+#define     DMA_TRANSACTION_DONE_INTERRUPT                      24
+#define     DMA_ABORT                                           1
+#define     DMA_START                                           0
+	u32		_unused0[2];
+	/* offset 0x0190, 0x01b0, 0x01d0, 0x01f0 */
+	u32		dmacount;
+#define     VALID_BIT                                           31
+#define     DMA_DIRECTION                                       30
+#define     DMA_DONE_INTERRUPT_ENABLE                           29
+#define     LAST_DESCRIPTOR                                     28
+#define     DMA_DESCRIPTOR_FIFO_VALIDATE                        27
+#define     DMA_OUT_CONTINUE                                    24
+#define     DMA_TRANSFER_MAX_LENGTH                             ((1UL<<24)-1)
+#define     DMA_TRANSFER_LENGTH                                 0	/* 23:0 */
+	/* offset 0x194, 0x1b4, 0x1d4, 0x1f4 */
+	u32		dmaaddr;
+	/* offset 0x198, 0x1b8, 0x1d8, 0x1f8 */
+	u32		dmadesc;
+#define     DMA_DESC_ONCHIP                                     0
+	u32		_unused1;
+} __attribute__ ((packed));
+
+#define INTERNAL_DESCRIPTOR_OFFSET                              0x4000
+
+/* dma control, BAR0 + 0x0680 */
+struct usb3380_dmap_regs {
+	u32     dmacountp;
+	u32     dmaaddrp;
+	u32     dmadescp;
+	u32     _unused1;
+} __attribute__ ((packed));
+
+/* configurable endpoint registers, BAR0 + 0x0300
+ */
+struct usb3380_ep_cfg {
+	/* offset 0x300, 0x320, 0x340, 0x360, 0x380 */
+	u32		ep_cfg;
+#define     USAGE_TYPE                      30  /* Legacy/Enhanced: 31:30 */
+#define     SYNC_TYPE                       28  /* Legacy/Enhanced: 29:28 */
+#define     MAX_BURST_SIZE                  24  /* Legacy/Enhanced: 27:24 */
+#define     SERVICE_INTERVAL                19  /* Legacy/Enhanced: 23:19 */
+#define     EP_FIFO_BYTE_COUNT              16	/* 18:16 */
+#define     IN_EP_FORMAT                    15	/* Legacy/Enhanced */
+#define		IN_ENDPOINT_ENABLE				14	/* Enhanced */
+#define		IN_ENDPOINT_TYPE				12	/* Enhanced: 13:12 */
+#define     BYTE_PACKING_ENABLE             11
+#define     ENDPOINT_ENABLE					10	/* Legacy/ep0 */
+#define 	OUT_ENDPOINT_ENABLE				10	/* Enhanced */
+#define     ENDPOINT_TYPE					8	/* Legacy/ep0: 9:8 */
+#define		OUT_ENDPOINT_TYPE				8	/* Enhanced: 9:8 */
+#define     ENDPOINT_DIRECTION				7	/* Legacy/ep0 */
+#define     ENDPOINT_NUMBER					0	/* 3:0 */
+	u32		_unused0[7];
+};
+
+struct usb3380_ep_regs {
+	/* ep0, ep1-out/in, ep2-out/in, ep3-out/in, ep4-out/in */
+	/* offset 0x304, 0x324/0x3e4, 0x344/0x404, 0x364/0x424, 0x384/0x444 */
+	u32		ep_rsp;
+#define     SET_NAK_PACKETS                                     15
+#define     SET_EP_HIDE_STATUS_STAGE                            14
+#define     SET_EP_FORCE_CRC_ERROR                              13
+#define     SET_INTERRUPT_MODE                                  12
+#define     SET_CONTROL_STATUS_STAGE_HANDSHAKE                  11
+#define     SET_NAK_OUT_PACKETS_MODE                            10
+#define     SET_ENDPOINT_TOGGLE                                 9
+#define     SET_ENDPOINT_HALT                                   8
+#define     CLEAR_NAK_PACKETS                                   7
+#define     CLEAR_EP_HIDE_STATUS_STAGE                          6
+#define     CLEAR_EP_FORCE_CRC_ERROR                            5
+#define     CLEAR_INTERRUPT_MODE                                4
+#define     CLEAR_CONTROL_STATUS_STAGE_HANDSHAKE                3
+#define     CLEAR_NAK_OUT_PACKETS_MODE                          2
+#define     CLEAR_ENDPOINT_TOGGLE                               1
+#define     CLEAR_ENDPOINT_HALT                                 0
+	u32		ep_irqenb;
+#define     DMA_CHANNEL_INTERRUPT_ENABLE                        14
+#define     ZLP_INTERRUPT_ENABLE                                13
+#define     SHORT_PACKET_OUT_DONE_INTERRUPT_ENABLE              6
+#define     SHORT_PACKET_RECEIVED_INTERRUPT_ENABLE              5
+#define     DATA_PACKET_RECEIVED_INTERRUPT_ENABLE               3
+#define     DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE            2
+#define     DATA_OUT_PING_TOKEN_INTERRUPT_ENABLE                1
+#define     DATA_IN_TOKEN_INTERRUPT_ENABLE                      0
+	u32		ep_stat;
+#define     FIFO_VALID_COUNT                                    24
+#define     HIGH_BANDWIDTH_OUT_TRANSACTION_PID                  22
+#define     TIMEOUT                                             21
+#define     USB_STALL_SENT                                      20
+#define     USB_IN_NAK_SENT                                     19
+#define     USB_IN_ACK_RCVD                                     18
+#define     USB_OUT_NAK_SENT                                    17
+#define     USB_OUT_ACK_SENT                                    16
+#define     ZLP_INTERRUPT                                       13
+#define     FIFO_FULL                                           11
+#define     FIFO_EMPTY                                          10
+#define     FIFO_FLUSH                                          9
+#define     FIFO_VALIDATE                                       8
+#define     SHORT_PACKET_TRANSFERRED_STATUS                     7
+#define     SHORT_OUT_PACKET_DONE_INTERRUPT                     6
+#define     SHORT_OUT_PACKET_RECEIVED_INTERRUPT                 5
+#define     NAK_PACKETS                                         4
+#define     DATA_PACKET_RECEIVED_INTERRUPT                      3
+#define     DATA_PACKET_TRANSMITTED_INTERRUPT                   2
+#define     DATA_OUT_PING_TOKEN_INTERRUPT                       1
+#define     DATA_IN_TOKEN_INTERRUPT                             0
+	/* offset 0x310, 0x330/0x3f0, 0x350/0x410, 0x370/0x430, 0x390/0x450 */
+	u32		ep_avail;
+	u32		ep_data;
+	u32		ep_data1;
+	u32		ep_val;
+	u32		_unused0; 
+} __attribute__ ((packed));
+
+struct usb3380_fifo_regs {
+	/* offset 0x0500, 0x0520, 0x0540, 0x0560, 0x0580 */
+	u32		ep_fifo_size_base;
+#define     OUT_FIFO_SIZE                                       0	/* 2:0 */
+#define     FIFO_SIZE_64                                        0
+#define     FIFO_SIZE_128                                       1
+#define     FIFO_SIZE_256                                       2
+#define     FIFO_SIZE_512                                       3
+#define     FIFO_SIZE_1024                                      4
+#define     FIFO_SIZE_2048                                      5
+#define     FIFO_SIZE_4096                                      6
+#define     OUT_FIFO_BASE_ADDRESS                               6	/* 14:6 */
+#define     IN_FIFO_SIZE                                        16	/* 18:16 */
+#define     IN_FIFO_BASE_ADDRESS                                22	/* 30:22 */
+	u32		ep_fifo_out_wrptr;
+	u32		ep_fifo_out_rdptr;
+	u32		ep_fifo_in_wrptr;
+	u32		ep_fifo_in_rdptr;
+	u32		unused[3];
+} __attribute__ ((packed));
+
+struct usb3380_ll_regs {
+	/* offset 0x700 */
+	u32     ll_ltssm_ctrl1;
+	u32     ll_ltssm_ctrl2;
+	u32     ll_ltssm_ctrl3;
+	u32     unused[2];
+	/* offset 0x714 */
+	u32     ll_general_ctrl0;
+	u32     ll_general_ctrl1;
+#define     FORCE_DL_BIT                                        5
+#define     DL_BIT_VALUE_FMW                                    6
+#define     RESEND_DPP_ON_LRTY_FMW                              7
+#define     SKP_THRESHOLD_ADJUST_FMW                            8	/* 13:8 */
+#define     PM_U1_ENABLE                                        16
+#define     PM_U2_ENABLE                                        17
+#define     PM_DIR_ENTRY_U1                                     18
+#define     PM_DIR_ENTRY_U2                                     19
+#define     PM_DIR_ENTRY_U3                                     20
+#define     PM_FORCE_LINK_ACCEPT                                22
+#define     PM_DIR_LINK_REJECT                                  23
+#define     PM_LGO_COLLISION_SEND_LAU                           24
+#define     PM_FORCE_U1_ENTRY                                   25
+#define     PM_FORCE_U2_ENTRY                                   26
+#define     PM_U1_AUTO_EXIT                                     27
+#define     PM_U2_AUTO_EXIT                                     28
+#define     PM_U3_AUTO_EXIT                                     29
+	u32     ll_general_ctrl2;
+#define     FORCE_INVERT_LANE_POLARITY                          6
+#define     SELECT_INVERT_LANE_POLARITY                         7
+	u32     ll_general_ctrl3;
+	u32     ll_general_ctrl4;
+	u32     ll_error_gen;
+} __attribute__ ((packed));
+
+struct usb3380_ll_tsn_regs {
+	/* offset 0x77c */
+	u32	ll_tsn_counters_2;
+#define     HOT_TX_NORESET_TS2					24 // [28:24]
+	u32	ll_tsn_counters_3;
+#define     HOT_RX_RESET_TS2					0  // [4:0]
+} __attribute__ ((packed));
+
+struct usb3380_ll_chi_regs {
+	/* offset 0x79c */
+	u32     ll_tsn_chicken_bit;
+#define     RECOVERY_IDLE_TO_RECOVER_FMW                        3 // [28:24]
+} __attribute__ ((packed));
+
+struct usb3380_pl_regs {
+        /* offset 0x800 */
+	u32 pl_reg_1;
+	u32 pl_reg_2;
+	u32 pl_reg_3;
+	u32 pl_reg_4;	
+	u32 pl_ep_ctrl;		//0x810
+// Protocol Layer Endpoint Control
+#define	    PL_EP_CTRL                                          0x810
+#define     ENDPOINT_SELECT                                         0               // [4:0]
+#define     EP_INITIALIZED                                          16
+#define     SEQUENCE_NUMBER_RESET                                   17
+#define     CLEAR_ACK_ERROR_CODE                                    20
+	u32 pl_reg_6;
+	u32 pl_reg_7;
+	u32 pl_reg_8;
+	u32 pl_ep_status_1;	//0x820
+// Protocol Layer Endpoint Status 1
+#define     PL_EP_STATUS_1                                      0x820
+#define     STATE                                                   16              // [23:16] Tip: Subdivided. See spec
+#define     ACK_GOOD_NORMAL                                         0x11    // for bits [20:16]
+#define     ACK_GOOD_MORE_ACKS_TO_COME                              0x16    // for bits [20:16]
+	u32 pl_ep_status_2;
+	u32 pl_ep_status_3;	//0x828
+// Protocol Layer Endpoint Status 3
+#define PL_EP_STATUS_3                                      	0x828
+#define     SEQUENCE_NUMBER                                         0               // [7:0]
+	u32 pl_ep_status_4;
+// Protocol Layer Endpoint Status 4
+#define PL_EP_STATUS_4             	                         0x82c
+	u32 pl_ep_cfg_4;
+// Protocol Layer Endpoint Configuration 4
+#define PL_EP_CFG_4                                     	 0x830
+#define     NON_CTRL_IN_TOLERATE_BAD_DIR                             6
+} __attribute__ ((packed));
+
+/* 
+ * Indexed Register
+ */
+static inline u32
+get_idx_reg (struct usb3380_regs __iomem *regs, u32 index)
+{
+	writel (index, &regs->idxaddr);
+	/* NOTE:  synchs device/cpu memory views */
+	return readl (&regs->idxdata);
+}
+
+static inline void
+set_idx_reg (struct usb3380_regs __iomem *regs, u32 index, u32 value)
+{
+	writel (index, &regs->idxaddr);
+	writel (value, &regs->idxdata);
+	/* posted, may not be visible yet */
+}
+
+/****************************************************************************/
+#define NR_DMA_CHANNEL  4	/* Number of DMA channel */
+
+#define NR_EPS_LEGCY    4	/* 4 endpoints in legacy mode */
+#define NR_EPS_ENHANCE  8	/* 8 endpoints in enhanced mode */
+
+#define EP0_HS_MAX_PACKET_SIZE	0x40	/* 64 */
+#define EP0_SS_MAX_PACKET_SIZE	0x200	/* 512 */
+
+
+/****************************************************************************/
+
+#endif
+
-- 
1.7.9.5

